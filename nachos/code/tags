!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
$	userprog/scheduler.o	/^/;"	v
$0	test/start.s	/^	addiu $2,$0,SYScall_Close$/;"	v
$0	test/start.s	/^	addiu $2,$0,SYScall_Create$/;"	v
$0	test/start.s	/^	addiu $2,$0,SYScall_Exec$/;"	v
$0	test/start.s	/^	addiu $2,$0,SYScall_Exit$/;"	v
$0	test/start.s	/^	addiu $2,$0,SYScall_Fork$/;"	v
$0	test/start.s	/^	addiu $2,$0,SYScall_GetPA$/;"	v
$0	test/start.s	/^	addiu $2,$0,SYScall_GetPID$/;"	v
$0	test/start.s	/^	addiu $2,$0,SYScall_GetPPID$/;"	v
$0	test/start.s	/^	addiu $2,$0,SYScall_GetReg$/;"	v
$0	test/start.s	/^	addiu $2,$0,SYScall_Halt$/;"	v
$0	test/start.s	/^	addiu $2,$0,SYScall_Join$/;"	v
$0	test/start.s	/^	addiu $2,$0,SYScall_NumInstr$/;"	v
$0	test/start.s	/^	addiu $2,$0,SYScall_Open$/;"	v
$0	test/start.s	/^	addiu $2,$0,SYScall_PrintIntHex$/;"	v
$0	test/start.s	/^	addiu $2,$0,SYScall_Read$/;"	v
$0	test/start.s	/^	addiu $2,$0,SYScall_Sleep$/;"	v
$0	test/start.s	/^	addiu $2,$0,SYScall_Time$/;"	v
$0	test/start.s	/^	addiu $2,$0,SYScall_Write$/;"	v
$0	test/start.s	/^	addiu $2,$0,SYScall_Yield$/;"	v
$0	test/start.s	/^        addiu $2,$0,SYScall_PrintChar$/;"	v
$0	test/start.s	/^        addiu $2,$0,SYScall_PrintInt$/;"	v
$0	test/start.s	/^        addiu $2,$0,SYScall_PrintString$/;"	v
A	test/matmult.c	/^int A[Dim][Dim];$/;"	v
A	test/sort.c	/^int A[1024];	\/* size of physical memory; with code, we'll run out of space!*\/$/;"	v
ADDRSPACE_H	userprog/addrspace.h	14;"	d
AOUTHDR	bin/coff.h	/^      } AOUTHDR;$/;"	t	typeref:struct:aouthdr
AOUTHSZ	bin/coff.h	34;"	d
ASSERT	threads/utility.h	84;"	d
ASSOC	bin/disasm.c	/^int NROWS=64, ASSOC=1, LINESIZE=4, RAND=0, LRD=0;$/;"	v
ASSOC	bin/main.c	/^int NROWS=64, ASSOC=1, LINESIZE=4, RAND=0, LRD=0;$/;"	v
Abort	machine/sysdep.cc	/^Abort()$/;"	f	signature:()
Abort	machine/sysdep.h	/^extern void Abort();$/;"	p	signature:()
Acquire	threads/synch.cc	/^void Lock::Acquire() {}$/;"	f	class:Lock	signature:()
Acquire	threads/synch.h	/^    void Acquire(); \/\/ these are the only operations on a lock$/;"	p	class:Lock	access:public	signature:()
Add	filesys/directory.cc	/^Directory::Add(char *name, int newSector)$/;"	f	class:Directory	signature:(char *name, int newSector)
Add	filesys/directory.h	/^    bool Add(char *name, int newSector);  \/\/ Add a file name into the directory$/;"	p	class:Directory	access:public	signature:(char *name, int newSector)
AddressErrorException	machine/machine.h	/^		     AddressErrorException, \/\/ Unaligned reference or one that$/;"	e	enum:ExceptionType
AllocBoundedArray	machine/sysdep.cc	/^AllocBoundedArray(int size)$/;"	f	signature:(int size)
AllocBoundedArray	machine/sysdep.h	/^extern char *AllocBoundedArray(int size);$/;"	p	signature:(int size)
Allocate	filesys/filehdr.cc	/^FileHeader::Allocate(BitMap *freeMap, int fileSize)$/;"	f	class:FileHeader	signature:(BitMap *freeMap, int fileSize)
Allocate	filesys/filehdr.h	/^    bool Allocate(BitMap *bitMap, int fileSize);\/\/ Initialize a file header, $/;"	p	class:FileHeader	access:public	signature:(BitMap *bitMap, int fileSize)
AllocateThreadStack	threads/thread.cc	/^NachOSThread::AllocateThreadStack (VoidFunctionPtr func, int arg)$/;"	f	class:NachOSThread	signature:(VoidFunctionPtr func, int arg)
AllocateThreadStack	threads/thread.h	/^    void AllocateThreadStack(VoidFunctionPtr func, int arg);$/;"	p	class:NachOSThread	access:private	signature:(VoidFunctionPtr func, int arg)
Append	threads/list.cc	/^List::Append(void *item)$/;"	f	class:List	signature:(void *item)
Append	threads/list.h	/^    void Append(void *item); 	\/\/ Put item at the end of the list$/;"	p	class:List	access:public	signature:(void *item)
Append	threads/synchlist.cc	/^SynchList::Append(void *item)$/;"	f	class:SynchList	signature:(void *item)
Append	threads/synchlist.h	/^    void Append(void *item);	\/\/ append item to the end of the list,$/;"	p	class:SynchList	access:public	signature:(void *item)
AssignNameToSocket	machine/sysdep.cc	/^AssignNameToSocket(char *socketName, int sockID)$/;"	f	signature:(char *socketName, int sockID)
AssignNameToSocket	machine/sysdep.h	/^extern void AssignNameToSocket(char *socketName, int sockID);$/;"	p	signature:(char *socketName, int sockID)
B	test/matmult.c	/^int B[Dim][Dim];$/;"	v
BCOND	machine/mipssim.h	106;"	d
BITMAP_H	userprog/bitmap.h	16;"	d
BLOCKED	threads/thread.h	/^enum ThreadStatus { JUST_CREATED, RUNNING, READY, BLOCKED };$/;"	e	enum:ThreadStatus
BadVAddrReg	machine/machine.h	70;"	d
BitMap	userprog/bitmap.cc	/^BitMap::BitMap(int nitems) $/;"	f	class:BitMap	signature:(int nitems)
BitMap	userprog/bitmap.h	/^    BitMap(int nitems);		\/\/ Initialize a bitmap, with "nitems" bits$/;"	p	class:BitMap	access:public	signature:(int nitems)
BitMap	userprog/bitmap.h	/^class BitMap {$/;"	c
BitMap::BitMap	userprog/bitmap.cc	/^BitMap::BitMap(int nitems) $/;"	f	class:BitMap	signature:(int nitems)
BitMap::BitMap	userprog/bitmap.h	/^    BitMap(int nitems);		\/\/ Initialize a bitmap, with "nitems" bits$/;"	p	class:BitMap	access:public	signature:(int nitems)
BitMap::Clear	userprog/bitmap.cc	/^BitMap::Clear(int which) $/;"	f	class:BitMap	signature:(int which)
BitMap::Clear	userprog/bitmap.h	/^    void Clear(int which);  	\/\/ Clear the "nth" bit$/;"	p	class:BitMap	access:public	signature:(int which)
BitMap::FetchFrom	userprog/bitmap.cc	/^BitMap::FetchFrom(OpenFile *file) $/;"	f	class:BitMap	signature:(OpenFile *file)
BitMap::FetchFrom	userprog/bitmap.h	/^    void FetchFrom(OpenFile *file); 	\/\/ fetch contents from disk $/;"	p	class:BitMap	access:public	signature:(OpenFile *file)
BitMap::Find	userprog/bitmap.cc	/^BitMap::Find() $/;"	f	class:BitMap	signature:()
BitMap::Find	userprog/bitmap.h	/^    int Find();            	\/\/ Return the # of a clear bit, and as a side$/;"	p	class:BitMap	access:public	signature:()
BitMap::Mark	userprog/bitmap.cc	/^BitMap::Mark(int which) $/;"	f	class:BitMap	signature:(int which)
BitMap::Mark	userprog/bitmap.h	/^    void Mark(int which);   	\/\/ Set the "nth" bit$/;"	p	class:BitMap	access:public	signature:(int which)
BitMap::NumClear	userprog/bitmap.cc	/^BitMap::NumClear() $/;"	f	class:BitMap	signature:()
BitMap::NumClear	userprog/bitmap.h	/^    int NumClear();		\/\/ Return the number of clear bits$/;"	p	class:BitMap	access:public	signature:()
BitMap::Print	userprog/bitmap.cc	/^BitMap::Print() $/;"	f	class:BitMap	signature:()
BitMap::Print	userprog/bitmap.h	/^    void Print();		\/\/ Print contents of bitmap$/;"	p	class:BitMap	access:public	signature:()
BitMap::Test	userprog/bitmap.cc	/^BitMap::Test(int which)$/;"	f	class:BitMap	signature:(int which)
BitMap::Test	userprog/bitmap.h	/^    bool Test(int which);   	\/\/ Is the "nth" bit set?$/;"	p	class:BitMap	access:public	signature:(int which)
BitMap::WriteBack	userprog/bitmap.cc	/^BitMap::WriteBack(OpenFile *file)$/;"	f	class:BitMap	signature:(OpenFile *file)
BitMap::WriteBack	userprog/bitmap.h	/^    void WriteBack(OpenFile *file); 	\/\/ write contents to disk$/;"	p	class:BitMap	access:public	signature:(OpenFile *file)
BitMap::map	userprog/bitmap.h	/^    unsigned int *map;			\/\/ bit storage$/;"	m	class:BitMap	access:private
BitMap::numBits	userprog/bitmap.h	/^    int numBits;			\/\/ number of bits in the bitmap$/;"	m	class:BitMap	access:private
BitMap::numWords	userprog/bitmap.h	/^    int numWords;			\/\/ number of words of bitmap storage$/;"	m	class:BitMap	access:private
BitMap::~BitMap	userprog/bitmap.cc	/^BitMap::~BitMap()$/;"	f	class:BitMap	signature:()
BitMap::~BitMap	userprog/bitmap.h	/^    ~BitMap();			\/\/ De-allocate bitmap$/;"	p	class:BitMap	access:public	signature:()
BitsInByte	userprog/bitmap.h	23;"	d
BitsInWord	userprog/bitmap.h	24;"	d
Broadcast	threads/synch.cc	/^void Condition::Broadcast(Lock* conditionLock) { }$/;"	f	class:Condition	signature:(Lock* conditionLock)
Broadcast	threads/synch.h	/^    void Broadcast(Lock *conditionLock);\/\/ the currentThread for all of $/;"	p	class:Condition	access:public	signature:(Lock *conditionLock)
BusErrorException	machine/machine.h	/^		     BusErrorException,     \/\/ Translation resulted in an $/;"	e	enum:ExceptionType
ByteToSector	filesys/filehdr.cc	/^FileHeader::ByteToSector(int offset)$/;"	f	class:FileHeader	signature:(int offset)
ByteToSector	filesys/filehdr.h	/^    int ByteToSector(int offset);	\/\/ Convert a byte offset into the file$/;"	p	class:FileHeader	access:public	signature:(int offset)
C	test/matmult.c	/^int C[Dim][Dim];$/;"	v
CONSOLE_H	machine/console.h	24;"	d
CallOnUserAbort	machine/sysdep.cc	/^CallOnUserAbort(VoidNoArgFunctionPtr func)$/;"	f	signature:(VoidNoArgFunctionPtr func)
CallOnUserAbort	machine/sysdep.h	/^extern void CallOnUserAbort(VoidNoArgFunctionPtr cleanUp);$/;"	p	signature:(VoidNoArgFunctionPtr cleanUp)
ChangeLevel	machine/interrupt.cc	/^Interrupt::ChangeLevel(IntStatus old, IntStatus now)$/;"	f	class:Interrupt	signature:(IntStatus old, IntStatus now)
ChangeLevel	machine/interrupt.h	/^    void ChangeLevel(IntStatus old, 	\/\/ SetLevel, without advancing the$/;"	p	class:Interrupt	access:private	signature:(IntStatus old, IntStatus now)
CheckCharAvail	machine/console.cc	/^Console::CheckCharAvail()$/;"	f	class:Console	signature:()
CheckCharAvail	machine/console.h	/^    void CheckCharAvail();$/;"	p	class:Console	access:public	signature:()
CheckEndian	machine/machine.cc	/^void CheckEndian()$/;"	f	file:	signature:()
CheckIfDue	machine/interrupt.cc	/^Interrupt::CheckIfDue(bool advanceClock)$/;"	f	class:Interrupt	signature:(bool advanceClock)
CheckIfDue	machine/interrupt.h	/^    bool CheckIfDue(bool advanceClock); \/\/ Check if an interrupt is supposed$/;"	p	class:Interrupt	access:private	signature:(bool advanceClock)
CheckOverflow	threads/thread.cc	/^NachOSThread::CheckOverflow()$/;"	f	class:NachOSThread	signature:()
CheckOverflow	threads/thread.h	/^    void CheckOverflow();   			\/\/ Check if thread has $/;"	p	class:NachOSThread	access:public	signature:()
CheckPktAvail	machine/network.cc	/^Network::CheckPktAvail()$/;"	f	class:Network	signature:()
CheckPktAvail	machine/network.h	/^    void CheckPktAvail();	\/\/ Check if there is an incoming packet$/;"	p	class:Network	access:public	signature:()
Cleanup	threads/system.cc	/^Cleanup()$/;"	f	signature:()
Cleanup	threads/system.cc	/^extern void Cleanup();$/;"	p	file:	signature:()
Cleanup	threads/system.h	/^extern void Cleanup();				\/\/ Cleanup, called when$/;"	p	signature:()
Clear	userprog/bitmap.cc	/^BitMap::Clear(int which) $/;"	f	class:BitMap	signature:(int which)
Clear	userprog/bitmap.h	/^    void Clear(int which);  	\/\/ Clear the "nth" bit$/;"	p	class:BitMap	access:public	signature:(int which)
Close	machine/sysdep.cc	/^Close(int fd)$/;"	f	signature:(int fd)
Close	machine/sysdep.h	/^extern void Close(int fd);$/;"	p	signature:(int fd)
CloseSocket	machine/sysdep.cc	/^CloseSocket(int sockID)$/;"	f	signature:(int sockID)
CloseSocket	machine/sysdep.h	/^extern void CloseSocket(int sockID);$/;"	p	signature:(int sockID)
ComputeLatency	machine/disk.cc	/^Disk::ComputeLatency(int newSector, bool writing)$/;"	f	class:Disk	signature:(int newSector, bool writing)
ComputeLatency	machine/disk.h	/^    int ComputeLatency(int newSector, bool writing);	$/;"	p	class:Disk	access:public	signature:(int newSector, bool writing)
Condition	threads/synch.cc	/^Condition::Condition(char* debugName) { }$/;"	f	class:Condition	signature:(char* debugName)
Condition	threads/synch.h	/^    Condition(char* debugName);		\/\/ initialize condition to $/;"	p	class:Condition	access:public	signature:(char* debugName)
Condition	threads/synch.h	/^class Condition {$/;"	c
Condition::Broadcast	threads/synch.cc	/^void Condition::Broadcast(Lock* conditionLock) { }$/;"	f	class:Condition	signature:(Lock* conditionLock)
Condition::Broadcast	threads/synch.h	/^    void Broadcast(Lock *conditionLock);\/\/ the currentThread for all of $/;"	p	class:Condition	access:public	signature:(Lock *conditionLock)
Condition::Condition	threads/synch.cc	/^Condition::Condition(char* debugName) { }$/;"	f	class:Condition	signature:(char* debugName)
Condition::Condition	threads/synch.h	/^    Condition(char* debugName);		\/\/ initialize condition to $/;"	p	class:Condition	access:public	signature:(char* debugName)
Condition::Signal	threads/synch.cc	/^void Condition::Signal(Lock* conditionLock) { }$/;"	f	class:Condition	signature:(Lock* conditionLock)
Condition::Signal	threads/synch.h	/^    void Signal(Lock *conditionLock);   \/\/ conditionLock must be held by$/;"	p	class:Condition	access:public	signature:(Lock *conditionLock)
Condition::Wait	threads/synch.cc	/^void Condition::Wait(Lock* conditionLock) { ASSERT(FALSE); }$/;"	f	class:Condition	signature:(Lock* conditionLock)
Condition::Wait	threads/synch.h	/^    void Wait(Lock *conditionLock); 	\/\/ these are the 3 operations on $/;"	p	class:Condition	access:public	signature:(Lock *conditionLock)
Condition::getName	threads/synch.h	/^    char* getName() { return (name); }$/;"	f	class:Condition	access:public	signature:()
Condition::name	threads/synch.h	/^    char* name;$/;"	m	class:Condition	access:private
Condition::~Condition	threads/synch.cc	/^Condition::~Condition() { }$/;"	f	class:Condition	signature:()
Condition::~Condition	threads/synch.h	/^    ~Condition();			\/\/ deallocate the condition$/;"	p	class:Condition	access:public	signature:()
Console	machine/console.cc	/^Console::Console(char *readFile, char *writeFile, VoidFunctionPtr readAvail, $/;"	f	class:Console	signature:(char *readFile, char *writeFile, VoidFunctionPtr readAvail, VoidFunctionPtr writeDone, int callArg)
Console	machine/console.h	/^    Console(char *readFile, char *writeFile, VoidFunctionPtr readAvail, $/;"	p	class:Console	access:public	signature:(char *readFile, char *writeFile, VoidFunctionPtr readAvail, VoidFunctionPtr writeDone, int callArg)
Console	machine/console.h	/^class Console {$/;"	c
Console::CheckCharAvail	machine/console.cc	/^Console::CheckCharAvail()$/;"	f	class:Console	signature:()
Console::CheckCharAvail	machine/console.h	/^    void CheckCharAvail();$/;"	p	class:Console	access:public	signature:()
Console::Console	machine/console.cc	/^Console::Console(char *readFile, char *writeFile, VoidFunctionPtr readAvail, $/;"	f	class:Console	signature:(char *readFile, char *writeFile, VoidFunctionPtr readAvail, VoidFunctionPtr writeDone, int callArg)
Console::Console	machine/console.h	/^    Console(char *readFile, char *writeFile, VoidFunctionPtr readAvail, $/;"	p	class:Console	access:public	signature:(char *readFile, char *writeFile, VoidFunctionPtr readAvail, VoidFunctionPtr writeDone, int callArg)
Console::GetChar	machine/console.cc	/^Console::GetChar()$/;"	f	class:Console	signature:()
Console::GetChar	machine/console.h	/^    char GetChar();	   	\/\/ Poll the console input.  If a char is $/;"	p	class:Console	access:public	signature:()
Console::PutChar	machine/console.cc	/^Console::PutChar(char ch)$/;"	f	class:Console	signature:(char ch)
Console::PutChar	machine/console.h	/^    void PutChar(char ch);	\/\/ Write "ch" to the console display, $/;"	p	class:Console	access:public	signature:(char ch)
Console::WriteDone	machine/console.cc	/^Console::WriteDone()$/;"	f	class:Console	signature:()
Console::WriteDone	machine/console.h	/^    void WriteDone();	 	\/\/ internal routines to signal I\/O completion$/;"	p	class:Console	access:public	signature:()
Console::handlerArg	machine/console.h	/^    int handlerArg;			\/\/ argument to be passed to the $/;"	m	class:Console	access:private
Console::incoming	machine/console.h	/^    char incoming;    			\/\/ Contains the character to be read,$/;"	m	class:Console	access:private
Console::putBusy	machine/console.h	/^    bool putBusy;    			\/\/ Is a PutChar operation in progress?$/;"	m	class:Console	access:private
Console::readFileNo	machine/console.h	/^    int readFileNo;			\/\/ UNIX file emulating the keyboard $/;"	m	class:Console	access:private
Console::readHandler	machine/console.h	/^    VoidFunctionPtr readHandler; 	\/\/ Interrupt handler to call when $/;"	m	class:Console	access:private
Console::writeFileNo	machine/console.h	/^    int writeFileNo;			\/\/ UNIX file emulating the display$/;"	m	class:Console	access:private
Console::writeHandler	machine/console.h	/^    VoidFunctionPtr writeHandler; 	\/\/ Interrupt handler to call when $/;"	m	class:Console	access:private
Console::~Console	machine/console.cc	/^Console::~Console()$/;"	f	class:Console	signature:()
Console::~Console	machine/console.h	/^    ~Console();			\/\/ clean up console emulation$/;"	p	class:Console	access:public	signature:()
ConsoleInput	userprog/syscall.h	105;"	d
ConsoleOutput	userprog/syscall.h	106;"	d
ConsoleReadInt	machine/interrupt.h	/^enum IntType { TimerInt, DiskInt, ConsoleWriteInt, ConsoleReadInt, $/;"	e	enum:IntType
ConsoleReadPoll	machine/console.cc	/^static void ConsoleReadPoll(int c) $/;"	f	file:	signature:(int c)
ConsoleTest	threads/main.cc	/^extern void StartUserProcess(char *file), ConsoleTest(char *in, char *out);$/;"	p	file:	signature:(char *in, char *out)
ConsoleTest	userprog/progtest.cc	/^ConsoleTest (char *in, char *out)$/;"	f	signature:(char *in, char *out)
ConsoleTime	machine/stats.h	56;"	d
ConsoleWriteDone	machine/console.cc	/^static void ConsoleWriteDone(int c)$/;"	f	file:	signature:(int c)
ConsoleWriteInt	machine/interrupt.h	/^enum IntType { TimerInt, DiskInt, ConsoleWriteInt, ConsoleReadInt, $/;"	e	enum:IntType
ContentSize	filesys/fstest.cc	113;"	d	file:
Contents	filesys/fstest.cc	112;"	d	file:
ConvertIntToHex	userprog/exception.cc	/^static void ConvertIntToHex (unsigned v, Console *console)$/;"	f	file:	signature:(unsigned v, Console *console)
Copy	filesys/fstest.cc	/^Copy(char *from, char *to)$/;"	f	signature:(char *from, char *to)
Copy	threads/main.cc	/^extern void ThreadTest(void), Copy(char *unixFile, char *nachosFile);$/;"	p	file:	signature:(char *unixFile, char *nachosFile)
Create	filesys/filesys.cc	/^FileSystem::Create(char *name, int initialSize)$/;"	f	class:FileSystem	signature:(char *name, int initialSize)
Create	filesys/filesys.h	/^    bool Create(char *name, int initialSize) { $/;"	f	class:FileSystem	access:public	signature:(char *name, int initialSize)
Create	filesys/filesys.h	/^    bool Create(char *name, int initialSize);  	$/;"	p	class:FileSystem	access:public	signature:(char *name, int initialSize)
DEBUG	threads/utility.cc	/^DEBUG(char flag, char *format, ...)$/;"	f	signature:(char flag, char *format, ...)
DEBUG	threads/utility.h	/^extern void DEBUG (char flag, char* format, ...);  	\/\/ Print debug message $/;"	p	signature:(char flag, char* format, ...)
DIRECTORY_H	filesys/directory.h	18;"	d
DISK_H	machine/disk.h	18;"	d
DeAssignNameToSocket	machine/sysdep.cc	/^DeAssignNameToSocket(char *socketName)$/;"	f	signature:(char *socketName)
DeAssignNameToSocket	machine/sysdep.h	/^extern void DeAssignNameToSocket(char *socketName);$/;"	p	signature:(char *socketName)
DeallocBoundedArray	machine/sysdep.cc	/^DeallocBoundedArray(char *ptr, int size)$/;"	f	signature:(char *ptr, int size)
DeallocBoundedArray	machine/sysdep.h	/^extern void DeallocBoundedArray(char *p, int size);$/;"	p	signature:(char *p, int size)
Deallocate	filesys/filehdr.cc	/^FileHeader::Deallocate(BitMap *freeMap)$/;"	f	class:FileHeader	signature:(BitMap *freeMap)
Deallocate	filesys/filehdr.h	/^    void Deallocate(BitMap *bitMap);  		\/\/ De-allocate this file's $/;"	p	class:FileHeader	access:public	signature:(BitMap *bitMap)
DebugInit	threads/utility.cc	/^DebugInit(char *flagList)$/;"	f	signature:(char *flagList)
DebugInit	threads/utility.h	/^extern void DebugInit(char* flags);	\/\/ enable printing debug messages$/;"	p	signature:(char* flags)
DebugIsEnabled	threads/utility.cc	/^DebugIsEnabled(char flag)$/;"	f	signature:(char flag)
DebugIsEnabled	threads/utility.h	/^extern bool DebugIsEnabled(char flag); 	\/\/ Is this debug flag enabled?$/;"	p	signature:(char flag)
Debugger	machine/machine.cc	/^void Machine::Debugger()$/;"	f	class:Machine	signature:()
Debugger	machine/machine.h	/^    void Debugger();		\/\/ invoke the user program debugger$/;"	p	class:Machine	access:public	signature:()
Decode	machine/machine.h	/^    void Decode();	\/\/ decode the binary representation of the instruction$/;"	p	class:Instruction	access:public	signature:()
Decode	machine/mipssim.cc	/^Instruction::Decode()$/;"	f	class:Instruction	signature:()
Delay	machine/sysdep.cc	/^Delay(int seconds)$/;"	f	signature:(int seconds)
Delay	machine/sysdep.h	/^extern void Delay(int seconds);$/;"	p	signature:(int seconds)
DelayedLoad	machine/machine.h	/^    void DelayedLoad(int nextReg, int nextVal);  	$/;"	p	class:Machine	access:public	signature:(int nextReg, int nextVal)
DelayedLoad	machine/mipssim.cc	/^Machine::DelayedLoad(int nextReg, int nextValue)$/;"	f	class:Machine	signature:(int nextReg, int nextValue)
Dim	test/matmult.c	12;"	d	file:
Directory	filesys/directory.cc	/^Directory::Directory(int size)$/;"	f	class:Directory	signature:(int size)
Directory	filesys/directory.h	/^    Directory(int size); 		\/\/ Initialize an empty directory$/;"	p	class:Directory	access:public	signature:(int size)
Directory	filesys/directory.h	/^class Directory {$/;"	c
Directory::Add	filesys/directory.cc	/^Directory::Add(char *name, int newSector)$/;"	f	class:Directory	signature:(char *name, int newSector)
Directory::Add	filesys/directory.h	/^    bool Add(char *name, int newSector);  \/\/ Add a file name into the directory$/;"	p	class:Directory	access:public	signature:(char *name, int newSector)
Directory::Directory	filesys/directory.cc	/^Directory::Directory(int size)$/;"	f	class:Directory	signature:(int size)
Directory::Directory	filesys/directory.h	/^    Directory(int size); 		\/\/ Initialize an empty directory$/;"	p	class:Directory	access:public	signature:(int size)
Directory::FetchFrom	filesys/directory.cc	/^Directory::FetchFrom(OpenFile *file)$/;"	f	class:Directory	signature:(OpenFile *file)
Directory::FetchFrom	filesys/directory.h	/^    void FetchFrom(OpenFile *file);  	\/\/ Init directory contents from disk$/;"	p	class:Directory	access:public	signature:(OpenFile *file)
Directory::Find	filesys/directory.cc	/^Directory::Find(char *name)$/;"	f	class:Directory	signature:(char *name)
Directory::Find	filesys/directory.h	/^    int Find(char *name);		\/\/ Find the sector number of the $/;"	p	class:Directory	access:public	signature:(char *name)
Directory::FindIndex	filesys/directory.cc	/^Directory::FindIndex(char *name)$/;"	f	class:Directory	signature:(char *name)
Directory::FindIndex	filesys/directory.h	/^    int FindIndex(char *name);		\/\/ Find the index into the directory $/;"	p	class:Directory	access:private	signature:(char *name)
Directory::List	filesys/directory.cc	/^Directory::List()$/;"	f	class:Directory	signature:()
Directory::List	filesys/directory.h	/^    void List();			\/\/ Print the names of all the files$/;"	p	class:Directory	access:public	signature:()
Directory::Print	filesys/directory.cc	/^Directory::Print()$/;"	f	class:Directory	signature:()
Directory::Print	filesys/directory.h	/^    void Print();			\/\/ Verbose print of the contents$/;"	p	class:Directory	access:public	signature:()
Directory::Remove	filesys/directory.cc	/^Directory::Remove(char *name)$/;"	f	class:Directory	signature:(char *name)
Directory::Remove	filesys/directory.h	/^    bool Remove(char *name);		\/\/ Remove a file from the directory$/;"	p	class:Directory	access:public	signature:(char *name)
Directory::WriteBack	filesys/directory.cc	/^Directory::WriteBack(OpenFile *file)$/;"	f	class:Directory	signature:(OpenFile *file)
Directory::WriteBack	filesys/directory.h	/^    void WriteBack(OpenFile *file);	\/\/ Write modifications to $/;"	p	class:Directory	access:public	signature:(OpenFile *file)
Directory::table	filesys/directory.h	/^    DirectoryEntry *table;		\/\/ Table of pairs: $/;"	m	class:Directory	access:private
Directory::tableSize	filesys/directory.h	/^    int tableSize;			\/\/ Number of directory entries$/;"	m	class:Directory	access:private
Directory::~Directory	filesys/directory.cc	/^Directory::~Directory()$/;"	f	class:Directory	signature:()
Directory::~Directory	filesys/directory.h	/^    ~Directory();			\/\/ De-allocate the directory$/;"	p	class:Directory	access:public	signature:()
DirectoryEntry	filesys/directory.h	/^class DirectoryEntry {$/;"	c
DirectoryEntry::inUse	filesys/directory.h	/^    bool inUse;				\/\/ Is this directory entry in use?$/;"	m	class:DirectoryEntry	access:public
DirectoryEntry::name	filesys/directory.h	/^    char name[FileNameMaxLen + 1];	\/\/ Text name for file, with +1 for $/;"	m	class:DirectoryEntry	access:public
DirectoryEntry::sector	filesys/directory.h	/^    int sector;				\/\/ Location on disk to find the $/;"	m	class:DirectoryEntry	access:public
DirectoryFileSize	filesys/filesys.cc	65;"	d	file:
DirectorySector	filesys/filesys.cc	58;"	d	file:
Disk	machine/disk.cc	/^Disk::Disk(char* name, VoidFunctionPtr callWhenDone, int callArg)$/;"	f	class:Disk	signature:(char* name, VoidFunctionPtr callWhenDone, int callArg)
Disk	machine/disk.h	/^    Disk(char* name, VoidFunctionPtr callWhenDone, int callArg);$/;"	p	class:Disk	access:public	signature:(char* name, VoidFunctionPtr callWhenDone, int callArg)
Disk	machine/disk.h	/^class Disk {$/;"	c
Disk::ComputeLatency	machine/disk.cc	/^Disk::ComputeLatency(int newSector, bool writing)$/;"	f	class:Disk	signature:(int newSector, bool writing)
Disk::ComputeLatency	machine/disk.h	/^    int ComputeLatency(int newSector, bool writing);	$/;"	p	class:Disk	access:public	signature:(int newSector, bool writing)
Disk::Disk	machine/disk.cc	/^Disk::Disk(char* name, VoidFunctionPtr callWhenDone, int callArg)$/;"	f	class:Disk	signature:(char* name, VoidFunctionPtr callWhenDone, int callArg)
Disk::Disk	machine/disk.h	/^    Disk(char* name, VoidFunctionPtr callWhenDone, int callArg);$/;"	p	class:Disk	access:public	signature:(char* name, VoidFunctionPtr callWhenDone, int callArg)
Disk::HandleInterrupt	machine/disk.cc	/^Disk::HandleInterrupt ()$/;"	f	class:Disk	signature:()
Disk::HandleInterrupt	machine/disk.h	/^    void HandleInterrupt();		\/\/ Interrupt handler, invoked when$/;"	p	class:Disk	access:public	signature:()
Disk::ModuloDiff	machine/disk.cc	/^Disk::ModuloDiff(int to, int from)$/;"	f	class:Disk	signature:(int to, int from)
Disk::ModuloDiff	machine/disk.h	/^    int ModuloDiff(int to, int from);        \/\/ # sectors between to and from$/;"	p	class:Disk	access:private	signature:(int to, int from)
Disk::ReadRequest	machine/disk.cc	/^Disk::ReadRequest(int sectorNumber, char* data)$/;"	f	class:Disk	signature:(int sectorNumber, char* data)
Disk::ReadRequest	machine/disk.h	/^    void ReadRequest(int sectorNumber, char* data);$/;"	p	class:Disk	access:public	signature:(int sectorNumber, char* data)
Disk::TimeToSeek	machine/disk.cc	/^Disk::TimeToSeek(int newSector, int *rotation) $/;"	f	class:Disk	signature:(int newSector, int *rotation)
Disk::TimeToSeek	machine/disk.h	/^    int TimeToSeek(int newSector, int *rotate); \/\/ time to get to the new track$/;"	p	class:Disk	access:private	signature:(int newSector, int *rotate)
Disk::UpdateLast	machine/disk.cc	/^Disk::UpdateLast(int newSector)$/;"	f	class:Disk	signature:(int newSector)
Disk::UpdateLast	machine/disk.h	/^    void UpdateLast(int newSector);$/;"	p	class:Disk	access:private	signature:(int newSector)
Disk::WriteRequest	machine/disk.cc	/^Disk::WriteRequest(int sectorNumber, char* data)$/;"	f	class:Disk	signature:(int sectorNumber, char* data)
Disk::WriteRequest	machine/disk.h	/^    void WriteRequest(int sectorNumber, char* data);$/;"	p	class:Disk	access:public	signature:(int sectorNumber, char* data)
Disk::active	machine/disk.h	/^    bool active;     			\/\/ Is a disk operation in progress?$/;"	m	class:Disk	access:private
Disk::bufferInit	machine/disk.h	/^    int bufferInit;			\/\/ When the track buffer started $/;"	m	class:Disk	access:private
Disk::fileno	machine/disk.h	/^    int fileno;				\/\/ UNIX file number for simulated disk $/;"	m	class:Disk	access:private
Disk::handler	machine/disk.h	/^    VoidFunctionPtr handler;		\/\/ Interrupt handler, to be invoked $/;"	m	class:Disk	access:private
Disk::handlerArg	machine/disk.h	/^    int handlerArg;			\/\/ Argument to interrupt handler $/;"	m	class:Disk	access:private
Disk::lastSector	machine/disk.h	/^    int lastSector;			\/\/ The previous disk request $/;"	m	class:Disk	access:private
Disk::~Disk	machine/disk.cc	/^Disk::~Disk()$/;"	f	class:Disk	signature:()
Disk::~Disk	machine/disk.h	/^    ~Disk();				\/\/ Deallocate the disk.$/;"	p	class:Disk	access:public	signature:()
DiskDone	machine/disk.cc	/^static void DiskDone(int arg) { ((Disk *)arg)->HandleInterrupt(); }$/;"	f	file:	signature:(int arg)
DiskInt	machine/interrupt.h	/^enum IntType { TimerInt, DiskInt, ConsoleWriteInt, ConsoleReadInt, $/;"	e	enum:IntType
DiskRequestDone	filesys/synchdisk.cc	/^DiskRequestDone (int arg)$/;"	f	file:	signature:(int arg)
DiskSize	machine/disk.cc	26;"	d	file:
DumpState	machine/interrupt.cc	/^Interrupt::DumpState()$/;"	f	class:Interrupt	signature:()
DumpState	machine/interrupt.h	/^    void DumpState();			\/\/ Print interrupt state$/;"	p	class:Interrupt	access:public	signature:()
DumpState	machine/machine.cc	/^Machine::DumpState()$/;"	f	class:Machine	signature:()
DumpState	machine/machine.h	/^    void DumpState();		\/\/ print the user CPU and memory state $/;"	p	class:Machine	access:public	signature:()
ENTRY	threads/switch.s	/^	.EXPORT SWITCH,ENTRY,PRIV_LEV=3,RTNVAL=GR$/;"	v
ENTRY	threads/switch.s	/^	.EXPORT ThreadRoot,ENTRY,PRIV_LEV=3,RTNVAL=GR$/;"	v
EXTRA	machine/mipssim.h	/^enum RegType { NONE, RS, RT, RD, EXTRA }; $/;"	e	enum:RegType
Enable	machine/interrupt.cc	/^Interrupt::Enable()$/;"	f	class:Interrupt	signature:()
Enable	machine/interrupt.h	/^    void Enable();			\/\/ Enable interrupts.$/;"	p	class:Interrupt	access:public	signature:()
ExceptionHandler	machine/machine.h	/^extern void ExceptionHandler(ExceptionType which);$/;"	p	signature:(ExceptionType which)
ExceptionHandler	userprog/exception.cc	/^ExceptionHandler(ExceptionType which)$/;"	f	signature:(ExceptionType which)
ExceptionType	machine/machine.h	/^enum ExceptionType { NoException,           \/\/ Everything ok!$/;"	g
Exit	machine/sysdep.cc	/^Exit(int exitCode)$/;"	f	signature:(int exitCode)
Exit	machine/sysdep.h	/^extern void Exit(int exitCode);$/;"	p	signature:(int exitCode)
FALSE	threads/utility.h	37;"	d
FAST	bin/execute.c	14;"	d	file:
FILEHDR_H	filesys/filehdr.h	15;"	d
FP	threads/switch.h	37;"	d
FP	threads/switch.h	77;"	d
FPState	threads/switch.h	143;"	d
FPState	threads/switch.h	56;"	d
FS_H	filesys/filesys.h	36;"	d
FetchFrom	filesys/directory.cc	/^Directory::FetchFrom(OpenFile *file)$/;"	f	class:Directory	signature:(OpenFile *file)
FetchFrom	filesys/directory.h	/^    void FetchFrom(OpenFile *file);  	\/\/ Init directory contents from disk$/;"	p	class:Directory	access:public	signature:(OpenFile *file)
FetchFrom	filesys/filehdr.cc	/^FileHeader::FetchFrom(int sector)$/;"	f	class:FileHeader	signature:(int sector)
FetchFrom	filesys/filehdr.h	/^    void FetchFrom(int sectorNumber); 	\/\/ Initialize file header from disk$/;"	p	class:FileHeader	access:public	signature:(int sectorNumber)
FetchFrom	userprog/bitmap.cc	/^BitMap::FetchFrom(OpenFile *file) $/;"	f	class:BitMap	signature:(OpenFile *file)
FetchFrom	userprog/bitmap.h	/^    void FetchFrom(OpenFile *file); 	\/\/ fetch contents from disk $/;"	p	class:BitMap	access:public	signature:(OpenFile *file)
FileHeader	filesys/filehdr.h	/^class FileHeader {$/;"	c
FileHeader::Allocate	filesys/filehdr.cc	/^FileHeader::Allocate(BitMap *freeMap, int fileSize)$/;"	f	class:FileHeader	signature:(BitMap *freeMap, int fileSize)
FileHeader::Allocate	filesys/filehdr.h	/^    bool Allocate(BitMap *bitMap, int fileSize);\/\/ Initialize a file header, $/;"	p	class:FileHeader	access:public	signature:(BitMap *bitMap, int fileSize)
FileHeader::ByteToSector	filesys/filehdr.cc	/^FileHeader::ByteToSector(int offset)$/;"	f	class:FileHeader	signature:(int offset)
FileHeader::ByteToSector	filesys/filehdr.h	/^    int ByteToSector(int offset);	\/\/ Convert a byte offset into the file$/;"	p	class:FileHeader	access:public	signature:(int offset)
FileHeader::Deallocate	filesys/filehdr.cc	/^FileHeader::Deallocate(BitMap *freeMap)$/;"	f	class:FileHeader	signature:(BitMap *freeMap)
FileHeader::Deallocate	filesys/filehdr.h	/^    void Deallocate(BitMap *bitMap);  		\/\/ De-allocate this file's $/;"	p	class:FileHeader	access:public	signature:(BitMap *bitMap)
FileHeader::FetchFrom	filesys/filehdr.cc	/^FileHeader::FetchFrom(int sector)$/;"	f	class:FileHeader	signature:(int sector)
FileHeader::FetchFrom	filesys/filehdr.h	/^    void FetchFrom(int sectorNumber); 	\/\/ Initialize file header from disk$/;"	p	class:FileHeader	access:public	signature:(int sectorNumber)
FileHeader::FileLength	filesys/filehdr.cc	/^FileHeader::FileLength()$/;"	f	class:FileHeader	signature:()
FileHeader::FileLength	filesys/filehdr.h	/^    int FileLength();			\/\/ Return the length of the file $/;"	p	class:FileHeader	access:public	signature:()
FileHeader::Print	filesys/filehdr.cc	/^FileHeader::Print()$/;"	f	class:FileHeader	signature:()
FileHeader::Print	filesys/filehdr.h	/^    void Print();			\/\/ Print the contents of the file.$/;"	p	class:FileHeader	access:public	signature:()
FileHeader::WriteBack	filesys/filehdr.cc	/^FileHeader::WriteBack(int sector)$/;"	f	class:FileHeader	signature:(int sector)
FileHeader::WriteBack	filesys/filehdr.h	/^    void WriteBack(int sectorNumber); 	\/\/ Write modifications to file header$/;"	p	class:FileHeader	access:public	signature:(int sectorNumber)
FileHeader::dataSectors	filesys/filehdr.h	/^    int dataSectors[NumDirect];		\/\/ Disk sector numbers for each data $/;"	m	class:FileHeader	access:private
FileHeader::numBytes	filesys/filehdr.h	/^    int numBytes;			\/\/ Number of bytes in the file$/;"	m	class:FileHeader	access:private
FileHeader::numSectors	filesys/filehdr.h	/^    int numSectors;			\/\/ Number of data sectors in the file$/;"	m	class:FileHeader	access:private
FileLength	filesys/filehdr.cc	/^FileHeader::FileLength()$/;"	f	class:FileHeader	signature:()
FileLength	filesys/filehdr.h	/^    int FileLength();			\/\/ Return the length of the file $/;"	p	class:FileHeader	access:public	signature:()
FileName	filesys/fstest.cc	111;"	d	file:
FileNameMaxLen	filesys/directory.h	22;"	d
FileRead	filesys/fstest.cc	/^FileRead()$/;"	f	file:	signature:()
FileSize	filesys/fstest.cc	114;"	d	file:
FileSystem	filesys/filesys.cc	/^FileSystem::FileSystem(bool format)$/;"	f	class:FileSystem	signature:(bool format)
FileSystem	filesys/filesys.h	/^    FileSystem(bool format) {}$/;"	f	class:FileSystem	access:public	signature:(bool format)
FileSystem	filesys/filesys.h	/^    FileSystem(bool format);		\/\/ Initialize the file system.$/;"	p	class:FileSystem	access:public	signature:(bool format)
FileSystem	filesys/filesys.h	/^class FileSystem {$/;"	c
FileSystem::Create	filesys/filesys.cc	/^FileSystem::Create(char *name, int initialSize)$/;"	f	class:FileSystem	signature:(char *name, int initialSize)
FileSystem::Create	filesys/filesys.h	/^    bool Create(char *name, int initialSize) { $/;"	f	class:FileSystem	access:public	signature:(char *name, int initialSize)
FileSystem::Create	filesys/filesys.h	/^    bool Create(char *name, int initialSize);  	$/;"	p	class:FileSystem	access:public	signature:(char *name, int initialSize)
FileSystem::FileSystem	filesys/filesys.cc	/^FileSystem::FileSystem(bool format)$/;"	f	class:FileSystem	signature:(bool format)
FileSystem::FileSystem	filesys/filesys.h	/^    FileSystem(bool format) {}$/;"	f	class:FileSystem	access:public	signature:(bool format)
FileSystem::FileSystem	filesys/filesys.h	/^    FileSystem(bool format);		\/\/ Initialize the file system.$/;"	p	class:FileSystem	access:public	signature:(bool format)
FileSystem::List	filesys/filesys.cc	/^FileSystem::List()$/;"	f	class:FileSystem	signature:()
FileSystem::List	filesys/filesys.h	/^    void List();			\/\/ List all the files in the file system$/;"	p	class:FileSystem	access:public	signature:()
FileSystem::Open	filesys/filesys.cc	/^FileSystem::Open(char *name)$/;"	f	class:FileSystem	signature:(char *name)
FileSystem::Open	filesys/filesys.h	/^    OpenFile* Open(char *name) {$/;"	f	class:FileSystem	access:public	signature:(char *name)
FileSystem::Open	filesys/filesys.h	/^    OpenFile* Open(char *name); 	\/\/ Open a file (UNIX open)$/;"	p	class:FileSystem	access:public	signature:(char *name)
FileSystem::Print	filesys/filesys.cc	/^FileSystem::Print()$/;"	f	class:FileSystem	signature:()
FileSystem::Print	filesys/filesys.h	/^    void Print();			\/\/ List all the files and their contents$/;"	p	class:FileSystem	access:public	signature:()
FileSystem::Remove	filesys/filesys.cc	/^FileSystem::Remove(char *name)$/;"	f	class:FileSystem	signature:(char *name)
FileSystem::Remove	filesys/filesys.h	/^    bool Remove(char *name) { return Unlink(name) == 0; }$/;"	f	class:FileSystem	access:public	signature:(char *name)
FileSystem::Remove	filesys/filesys.h	/^    bool Remove(char *name);  		\/\/ Delete a file (UNIX unlink)$/;"	p	class:FileSystem	access:public	signature:(char *name)
FileSystem::directoryFile	filesys/filesys.h	/^   OpenFile* directoryFile;		\/\/ "Root" directory -- list of $/;"	m	class:FileSystem	access:private
FileSystem::freeMapFile	filesys/filesys.h	/^   OpenFile* freeMapFile;		\/\/ Bit map of free disk blocks,$/;"	m	class:FileSystem	access:private
FileWrite	filesys/fstest.cc	/^FileWrite()$/;"	f	file:	signature:()
Find	filesys/directory.cc	/^Directory::Find(char *name)$/;"	f	class:Directory	signature:(char *name)
Find	filesys/directory.h	/^    int Find(char *name);		\/\/ Find the sector number of the $/;"	p	class:Directory	access:public	signature:(char *name)
Find	userprog/bitmap.cc	/^BitMap::Find() $/;"	f	class:BitMap	signature:()
Find	userprog/bitmap.h	/^    int Find();            	\/\/ Return the # of a clear bit, and as a side$/;"	p	class:BitMap	access:public	signature:()
FindIndex	filesys/directory.cc	/^Directory::FindIndex(char *name)$/;"	f	class:Directory	signature:(char *name)
FindIndex	filesys/directory.h	/^    int FindIndex(char *name);		\/\/ Find the index into the directory $/;"	p	class:Directory	access:private	signature:(char *name)
FindNextThreadToRun	threads/scheduler.cc	/^NachOSscheduler::FindNextThreadToRun ()$/;"	f	class:NachOSscheduler	signature:()
FindNextThreadToRun	threads/scheduler.h	/^    NachOSThread* FindNextThreadToRun();		\/\/ Dequeue first thread on the ready $/;"	p	class:NachOSscheduler	access:public	signature:()
FinishThread	threads/thread.cc	/^NachOSThread::FinishThread ()$/;"	f	class:NachOSThread	signature:()
FinishThread	threads/thread.h	/^    void FinishThread();  				\/\/ The thread is done executing$/;"	p	class:NachOSThread	access:public	signature:()
FreeMapFileSize	filesys/filesys.cc	63;"	d	file:
FreeMapSector	filesys/filesys.cc	57;"	d	file:
Get	network/post.cc	/^MailBox::Get(PacketHeader *pktHdr, MailHeader *mailHdr, char *data) $/;"	f	class:MailBox	signature:(PacketHeader *pktHdr, MailHeader *mailHdr, char *data)
Get	network/post.h	/^    void Get(PacketHeader *pktHdr, MailHeader *mailHdr, char *data); $/;"	p	class:MailBox	access:public	signature:(PacketHeader *pktHdr, MailHeader *mailHdr, char *data)
GetChar	machine/console.cc	/^Console::GetChar()$/;"	f	class:Console	signature:()
GetChar	machine/console.h	/^    char GetChar();	   	\/\/ Poll the console input.  If a char is $/;"	p	class:Console	access:public	signature:()
GetPhysAddr	userprog/exception.cc	/^int GetPhysAddr(int virtAddr) {$/;"	f	signature:(int virtAddr)
HI	bin/execute.c	/^int HI, LO;			\/* mul\/div machine registers *\/$/;"	v
Halt	machine/interrupt.cc	/^Interrupt::Halt()$/;"	f	class:Interrupt	signature:()
Halt	machine/interrupt.h	/^    void Halt(); 			\/\/ quit and print out stats$/;"	p	class:Interrupt	access:public	signature:()
HandleInterrupt	machine/disk.cc	/^Disk::HandleInterrupt ()$/;"	f	class:Disk	signature:()
HandleInterrupt	machine/disk.h	/^    void HandleInterrupt();		\/\/ Interrupt handler, invoked when$/;"	p	class:Disk	access:public	signature:()
HiReg	machine/machine.h	63;"	d
I0	threads/switch.h	67;"	d
I1	threads/switch.h	68;"	d
I2	threads/switch.h	69;"	d
I3	threads/switch.h	70;"	d
I4	threads/switch.h	71;"	d
I5	threads/switch.h	72;"	d
I6	threads/switch.h	73;"	d
I7	threads/switch.h	74;"	d
IFMT	machine/mipssim.h	108;"	d
INTERRUPT_H	machine/interrupt.h	36;"	d
IN_ASM	test/start.s	9;"	d	file:
IOCPARM_MASK	bin/system.c	89;"	d	file:
I_ADD	bin/encode.h	84;"	d
I_ADDI	bin/encode.h	20;"	d
I_ADDIU	bin/encode.h	21;"	d
I_ADDU	bin/encode.h	85;"	d
I_AND	bin/encode.h	88;"	d
I_ANDI	bin/encode.h	24;"	d
I_BCOND	bin/encode.h	13;"	d
I_BEQ	bin/encode.h	16;"	d
I_BGEZ	bin/encode.h	100;"	d
I_BGEZAL	bin/encode.h	103;"	d
I_BGTZ	bin/encode.h	19;"	d
I_BLEZ	bin/encode.h	18;"	d
I_BLTZ	bin/encode.h	99;"	d
I_BLTZAL	bin/encode.h	102;"	d
I_BNE	bin/encode.h	17;"	d
I_BREAK	bin/encode.h	72;"	d
I_COP0	bin/encode.h	28;"	d
I_COP1	bin/encode.h	29;"	d
I_COP2	bin/encode.h	30;"	d
I_COP3	bin/encode.h	31;"	d
I_DIV	bin/encode.h	81;"	d
I_DIVU	bin/encode.h	82;"	d
I_J	bin/encode.h	14;"	d
I_JAL	bin/encode.h	15;"	d
I_JALR	bin/encode.h	69;"	d
I_JR	bin/encode.h	68;"	d
I_LB	bin/encode.h	33;"	d
I_LBU	bin/encode.h	37;"	d
I_LH	bin/encode.h	34;"	d
I_LHU	bin/encode.h	38;"	d
I_LUI	bin/encode.h	27;"	d
I_LW	bin/encode.h	36;"	d
I_LWC0	bin/encode.h	48;"	d
I_LWC1	bin/encode.h	49;"	d
I_LWC2	bin/encode.h	50;"	d
I_LWC3	bin/encode.h	51;"	d
I_LWL	bin/encode.h	35;"	d
I_LWR	bin/encode.h	39;"	d
I_MFHI	bin/encode.h	74;"	d
I_MFLO	bin/encode.h	76;"	d
I_MTHI	bin/encode.h	75;"	d
I_MTLO	bin/encode.h	77;"	d
I_MULT	bin/encode.h	79;"	d
I_MULTU	bin/encode.h	80;"	d
I_NOP	bin/encode.h	107;"	d
I_NOR	bin/encode.h	91;"	d
I_OR	bin/encode.h	89;"	d
I_ORI	bin/encode.h	25;"	d
I_SB	bin/encode.h	41;"	d
I_SH	bin/encode.h	42;"	d
I_SLL	bin/encode.h	60;"	d
I_SLLV	bin/encode.h	64;"	d
I_SLT	bin/encode.h	93;"	d
I_SLTI	bin/encode.h	22;"	d
I_SLTIU	bin/encode.h	23;"	d
I_SLTU	bin/encode.h	94;"	d
I_SPECIAL	bin/encode.h	12;"	d
I_SRA	bin/encode.h	63;"	d
I_SRAV	bin/encode.h	67;"	d
I_SRL	bin/encode.h	62;"	d
I_SRLV	bin/encode.h	66;"	d
I_SUB	bin/encode.h	86;"	d
I_SUBU	bin/encode.h	87;"	d
I_SW	bin/encode.h	44;"	d
I_SWC0	bin/encode.h	53;"	d
I_SWC1	bin/encode.h	54;"	d
I_SWC2	bin/encode.h	55;"	d
I_SWC3	bin/encode.h	56;"	d
I_SWL	bin/encode.h	43;"	d
I_SWR	bin/encode.h	46;"	d
I_SYSCALL	bin/encode.h	71;"	d
I_XOR	bin/encode.h	90;"	d
I_XORI	bin/encode.h	26;"	d
Idle	machine/interrupt.cc	/^Interrupt::Idle()$/;"	f	class:Interrupt	signature:()
Idle	machine/interrupt.h	/^    void Idle(); 			\/\/ The ready queue is empty, roll $/;"	p	class:Interrupt	access:public	signature:()
IdleMode	machine/interrupt.h	/^enum MachineStatus {IdleMode, SystemMode, UserMode};$/;"	e	enum:MachineStatus
IllegalInstrException	machine/machine.h	/^		     IllegalInstrException, \/\/ Unimplemented or reserved instr.$/;"	e	enum:ExceptionType
IncomingPacket	network/post.cc	/^PostOffice::IncomingPacket()$/;"	f	class:PostOffice	signature:()
IncomingPacket	network/post.h	/^    void IncomingPacket();	\/\/ Interrupt handler, called when incoming$/;"	p	class:PostOffice	access:public	signature:()
IndexToAddr	machine/mipssim.h	94;"	d
InitSocketName	machine/sysdep.cc	/^InitSocketName(struct sockaddr_un *uname, char *name)$/;"	f	file:	signature:(struct sockaddr_un *uname, char *name)
InitUserCPURegisters	userprog/addrspace.cc	/^ProcessAddrSpace::InitUserCPURegisters()$/;"	f	class:ProcessAddrSpace	signature:()
InitUserCPURegisters	userprog/addrspace.h	/^    void InitUserCPURegisters();		\/\/ Initialize user-level CPU registers,$/;"	p	class:ProcessAddrSpace	access:public	signature:()
InitialArg	threads/switch.h	117;"	d
InitialArg	threads/switch.h	150;"	d
InitialArg	threads/switch.h	51;"	d
InitialArg	threads/switch.h	82;"	d
InitialArgState	threads/switch.h	123;"	d
InitialArgState	threads/switch.h	145;"	d
InitialArgState	threads/switch.h	58;"	d
InitialArgState	threads/switch.h	88;"	d
InitialPC	threads/switch.h	116;"	d
InitialPC	threads/switch.h	149;"	d
InitialPC	threads/switch.h	50;"	d
InitialPC	threads/switch.h	81;"	d
InitialPCState	threads/switch.h	122;"	d
InitialPCState	threads/switch.h	144;"	d
InitialPCState	threads/switch.h	57;"	d
InitialPCState	threads/switch.h	87;"	d
Initialize	threads/system.cc	/^Initialize(int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
Initialize	threads/system.h	/^extern void Initialize(int argc, char **argv); 	\/\/ Initialization,$/;"	p	signature:(int argc, char **argv)
Instruction	machine/machine.h	/^class Instruction {$/;"	c
Instruction::Decode	machine/machine.h	/^    void Decode();	\/\/ decode the binary representation of the instruction$/;"	p	class:Instruction	access:public	signature:()
Instruction::Decode	machine/mipssim.cc	/^Instruction::Decode()$/;"	f	class:Instruction	signature:()
Instruction::extra	machine/machine.h	/^    int extra;       \/\/ Immediate or target or shamt field or offset.$/;"	m	class:Instruction	access:public
Instruction::opCode	machine/machine.h	/^    char opCode;     \/\/ Type of instruction.  This is NOT the same as the$/;"	m	class:Instruction	access:public
Instruction::rd	machine/machine.h	/^    char rs, rt, rd; \/\/ Three registers from instruction.$/;"	m	class:Instruction	access:public
Instruction::rs	machine/machine.h	/^    char rs, rt, rd; \/\/ Three registers from instruction.$/;"	m	class:Instruction	access:public
Instruction::rt	machine/machine.h	/^    char rs, rt, rd; \/\/ Three registers from instruction.$/;"	m	class:Instruction	access:public
Instruction::value	machine/machine.h	/^    unsigned int value; \/\/ binary representation of the instruction$/;"	m	class:Instruction	access:public
IntOff	machine/interrupt.h	/^enum IntStatus { IntOff, IntOn };$/;"	e	enum:IntStatus
IntOn	machine/interrupt.h	/^enum IntStatus { IntOff, IntOn };$/;"	e	enum:IntStatus
IntStatus	machine/interrupt.h	/^enum IntStatus { IntOff, IntOn };$/;"	g
IntType	machine/interrupt.h	/^enum IntType { TimerInt, DiskInt, ConsoleWriteInt, ConsoleReadInt, $/;"	g
Interrupt	machine/interrupt.cc	/^Interrupt::Interrupt()$/;"	f	class:Interrupt	signature:()
Interrupt	machine/interrupt.h	/^    Interrupt();			\/\/ initialize the interrupt simulation$/;"	p	class:Interrupt	access:public	signature:()
Interrupt	machine/interrupt.h	/^class Interrupt {$/;"	c
Interrupt::ChangeLevel	machine/interrupt.cc	/^Interrupt::ChangeLevel(IntStatus old, IntStatus now)$/;"	f	class:Interrupt	signature:(IntStatus old, IntStatus now)
Interrupt::ChangeLevel	machine/interrupt.h	/^    void ChangeLevel(IntStatus old, 	\/\/ SetLevel, without advancing the$/;"	p	class:Interrupt	access:private	signature:(IntStatus old, IntStatus now)
Interrupt::CheckIfDue	machine/interrupt.cc	/^Interrupt::CheckIfDue(bool advanceClock)$/;"	f	class:Interrupt	signature:(bool advanceClock)
Interrupt::CheckIfDue	machine/interrupt.h	/^    bool CheckIfDue(bool advanceClock); \/\/ Check if an interrupt is supposed$/;"	p	class:Interrupt	access:private	signature:(bool advanceClock)
Interrupt::DumpState	machine/interrupt.cc	/^Interrupt::DumpState()$/;"	f	class:Interrupt	signature:()
Interrupt::DumpState	machine/interrupt.h	/^    void DumpState();			\/\/ Print interrupt state$/;"	p	class:Interrupt	access:public	signature:()
Interrupt::Enable	machine/interrupt.cc	/^Interrupt::Enable()$/;"	f	class:Interrupt	signature:()
Interrupt::Enable	machine/interrupt.h	/^    void Enable();			\/\/ Enable interrupts.$/;"	p	class:Interrupt	access:public	signature:()
Interrupt::Halt	machine/interrupt.cc	/^Interrupt::Halt()$/;"	f	class:Interrupt	signature:()
Interrupt::Halt	machine/interrupt.h	/^    void Halt(); 			\/\/ quit and print out stats$/;"	p	class:Interrupt	access:public	signature:()
Interrupt::Idle	machine/interrupt.cc	/^Interrupt::Idle()$/;"	f	class:Interrupt	signature:()
Interrupt::Idle	machine/interrupt.h	/^    void Idle(); 			\/\/ The ready queue is empty, roll $/;"	p	class:Interrupt	access:public	signature:()
Interrupt::Interrupt	machine/interrupt.cc	/^Interrupt::Interrupt()$/;"	f	class:Interrupt	signature:()
Interrupt::Interrupt	machine/interrupt.h	/^    Interrupt();			\/\/ initialize the interrupt simulation$/;"	p	class:Interrupt	access:public	signature:()
Interrupt::OneTick	machine/interrupt.cc	/^Interrupt::OneTick()$/;"	f	class:Interrupt	signature:()
Interrupt::OneTick	machine/interrupt.h	/^    void OneTick();       		\/\/ Advance simulated time$/;"	p	class:Interrupt	access:public	signature:()
Interrupt::Schedule	machine/interrupt.cc	/^Interrupt::Schedule(VoidFunctionPtr handler, int arg, int fromNow, IntType type)$/;"	f	class:Interrupt	signature:(VoidFunctionPtr handler, int arg, int fromNow, IntType type)
Interrupt::Schedule	machine/interrupt.h	/^    void Schedule(VoidFunctionPtr handler,\/\/ Schedule an interrupt to occur$/;"	p	class:Interrupt	access:public	signature:(VoidFunctionPtr handler, int arg, int when, IntType type)
Interrupt::SetLevel	machine/interrupt.cc	/^Interrupt::SetLevel(IntStatus now)$/;"	f	class:Interrupt	signature:(IntStatus now)
Interrupt::SetLevel	machine/interrupt.h	/^    IntStatus SetLevel(IntStatus level);\/\/ Disable or enable interrupts $/;"	p	class:Interrupt	access:public	signature:(IntStatus level)
Interrupt::YieldOnReturn	machine/interrupt.cc	/^Interrupt::YieldOnReturn()$/;"	f	class:Interrupt	signature:()
Interrupt::YieldOnReturn	machine/interrupt.h	/^    void YieldOnReturn();		\/\/ cause a context switch on return $/;"	p	class:Interrupt	access:public	signature:()
Interrupt::getLevel	machine/interrupt.h	/^    IntStatus getLevel() {return level;}\/\/ Return whether interrupts$/;"	f	class:Interrupt	access:public	signature:()
Interrupt::getStatus	machine/interrupt.h	/^    MachineStatus getStatus() { return status; } \/\/ idle, kernel, user$/;"	f	class:Interrupt	access:public	signature:()
Interrupt::inHandler	machine/interrupt.h	/^    bool inHandler;		\/\/ TRUE if we are running an interrupt handler$/;"	m	class:Interrupt	access:private
Interrupt::level	machine/interrupt.h	/^    IntStatus level;		\/\/ are interrupts enabled or disabled?$/;"	m	class:Interrupt	access:private
Interrupt::pending	machine/interrupt.h	/^    List *pending;		\/\/ the list of interrupts scheduled$/;"	m	class:Interrupt	access:private
Interrupt::setStatus	machine/interrupt.h	/^    void setStatus(MachineStatus st) { status = st; }$/;"	f	class:Interrupt	access:public	signature:(MachineStatus st)
Interrupt::status	machine/interrupt.h	/^    MachineStatus status;	\/\/ idle, kernel mode, user mode$/;"	m	class:Interrupt	access:private
Interrupt::yieldOnReturn	machine/interrupt.h	/^    bool yieldOnReturn; 	\/\/ TRUE if we are to context switch$/;"	m	class:Interrupt	access:private
Interrupt::~Interrupt	machine/interrupt.cc	/^Interrupt::~Interrupt()$/;"	f	class:Interrupt	signature:()
Interrupt::~Interrupt	machine/interrupt.h	/^    ~Interrupt();			\/\/ de-allocate data structures$/;"	p	class:Interrupt	access:public	signature:()
InterruptEnable	threads/thread.cc	/^static void InterruptEnable() { interrupt->Enable(); }$/;"	f	file:	signature:()
IsEmpty	threads/list.cc	/^List::IsEmpty() $/;"	f	class:List	signature:()
IsEmpty	threads/list.h	/^    bool IsEmpty();		\/\/ is the list empty? $/;"	p	class:List	access:public	signature:()
JFMT	machine/mipssim.h	109;"	d
JUST_CREATED	threads/thread.h	/^enum ThreadStatus { JUST_CREATED, RUNNING, READY, BLOCKED };$/;"	e	enum:ThreadStatus
L	test/matmult.o	/^b/;"	v
LINESIZE	bin/disasm.c	/^int NROWS=64, ASSOC=1, LINESIZE=4, RAND=0, LRD=0;$/;"	v
LINESIZE	bin/main.c	/^int NROWS=64, ASSOC=1, LINESIZE=4, RAND=0, LRD=0;$/;"	v
LIST_H	threads/list.h	14;"	d
LO	bin/execute.c	/^int HI, LO;			\/* mul\/div machine registers *\/$/;"	v
LOADSECTION	bin/disasm.c	69;"	d	file:
LOADSECTION	bin/main.c	112;"	d	file:
LRD	bin/disasm.c	/^int NROWS=64, ASSOC=1, LINESIZE=4, RAND=0, LRD=0;$/;"	v
LRD	bin/main.c	/^int NROWS=64, ASSOC=1, LINESIZE=4, RAND=0, LRD=0;$/;"	v
Length	filesys/openfile.cc	/^OpenFile::Length() $/;"	f	class:OpenFile	signature:()
Length	filesys/openfile.h	/^    int Length() { Lseek(file, 0, 2); return Tell(file); }$/;"	f	class:OpenFile	access:public	signature:()
Length	filesys/openfile.h	/^    int Length(); 			\/\/ Return the number of bytes in the$/;"	p	class:OpenFile	access:public	signature:()
List	filesys/directory.cc	/^Directory::List()$/;"	f	class:Directory	signature:()
List	filesys/directory.h	/^    void List();			\/\/ Print the names of all the files$/;"	p	class:Directory	access:public	signature:()
List	filesys/filesys.cc	/^FileSystem::List()$/;"	f	class:FileSystem	signature:()
List	filesys/filesys.h	/^    void List();			\/\/ List all the files in the file system$/;"	p	class:FileSystem	access:public	signature:()
List	threads/list.cc	/^List::List()$/;"	f	class:List	signature:()
List	threads/list.h	/^    List();			\/\/ initialize the list$/;"	p	class:List	access:public	signature:()
List	threads/list.h	/^class List {$/;"	c
List::Append	threads/list.cc	/^List::Append(void *item)$/;"	f	class:List	signature:(void *item)
List::Append	threads/list.h	/^    void Append(void *item); 	\/\/ Put item at the end of the list$/;"	p	class:List	access:public	signature:(void *item)
List::IsEmpty	threads/list.cc	/^List::IsEmpty() $/;"	f	class:List	signature:()
List::IsEmpty	threads/list.h	/^    bool IsEmpty();		\/\/ is the list empty? $/;"	p	class:List	access:public	signature:()
List::List	threads/list.cc	/^List::List()$/;"	f	class:List	signature:()
List::List	threads/list.h	/^    List();			\/\/ initialize the list$/;"	p	class:List	access:public	signature:()
List::Mapcar	threads/list.cc	/^List::Mapcar(VoidFunctionPtr func)$/;"	f	class:List	signature:(VoidFunctionPtr func)
List::Mapcar	threads/list.h	/^    void Mapcar(VoidFunctionPtr func);	\/\/ Apply "func" to every element $/;"	p	class:List	access:public	signature:(VoidFunctionPtr func)
List::Prepend	threads/list.cc	/^List::Prepend(void *item)$/;"	f	class:List	signature:(void *item)
List::Prepend	threads/list.h	/^    void Prepend(void *item); 	\/\/ Put item at the beginning of the list$/;"	p	class:List	access:public	signature:(void *item)
List::Remove	threads/list.cc	/^List::Remove()$/;"	f	class:List	signature:()
List::Remove	threads/list.h	/^    void *Remove(); 	 	\/\/ Take item off the front of the list$/;"	p	class:List	access:public	signature:()
List::SortedInsert	threads/list.cc	/^List::SortedInsert(void *item, int sortKey)$/;"	f	class:List	signature:(void *item, int sortKey)
List::SortedInsert	threads/list.h	/^    void SortedInsert(void *item, int sortKey);	\/\/ Put item into list$/;"	p	class:List	access:public	signature:(void *item, int sortKey)
List::SortedRemove	threads/list.cc	/^List::SortedRemove(int *keyPtr)$/;"	f	class:List	signature:(int *keyPtr)
List::SortedRemove	threads/list.h	/^    void *SortedRemove(int *keyPtr); 	  	\/\/ Remove first item from list$/;"	p	class:List	access:public	signature:(int *keyPtr)
List::first	threads/list.h	/^    ListElement *first;  	\/\/ Head of the list, NULL if list is empty$/;"	m	class:List	access:private
List::last	threads/list.h	/^    ListElement *last;		\/\/ Last element of list$/;"	m	class:List	access:private
List::~List	threads/list.cc	/^List::~List()$/;"	f	class:List	signature:()
List::~List	threads/list.h	/^    ~List();			\/\/ de-allocate the list$/;"	p	class:List	access:public	signature:()
ListElement	threads/list.cc	/^ListElement::ListElement(void *itemPtr, int sortKey)$/;"	f	class:ListElement	signature:(void *itemPtr, int sortKey)
ListElement	threads/list.h	/^     ListElement(void *itemPtr, int sortKey);	\/\/ initialize a list element$/;"	p	class:ListElement	access:public	signature:(void *itemPtr, int sortKey)
ListElement	threads/list.h	/^class ListElement {$/;"	c
ListElement::ListElement	threads/list.cc	/^ListElement::ListElement(void *itemPtr, int sortKey)$/;"	f	class:ListElement	signature:(void *itemPtr, int sortKey)
ListElement::ListElement	threads/list.h	/^     ListElement(void *itemPtr, int sortKey);	\/\/ initialize a list element$/;"	p	class:ListElement	access:public	signature:(void *itemPtr, int sortKey)
ListElement::item	threads/list.h	/^     void *item; 	    	\/\/ pointer to item on the list$/;"	m	class:ListElement	access:public
ListElement::key	threads/list.h	/^     int key;		    	\/\/ priority, for a sorted list$/;"	m	class:ListElement	access:public
ListElement::next	threads/list.h	/^     ListElement *next;		\/\/ next element on list, $/;"	m	class:ListElement	access:public
LoReg	machine/machine.h	64;"	d
LoadReg	machine/machine.h	68;"	d
LoadValueReg	machine/machine.h	69;"	d
Lock	threads/synch.cc	/^Lock::Lock(char* debugName) {}$/;"	f	class:Lock	signature:(char* debugName)
Lock	threads/synch.h	/^    Lock(char* debugName);  		\/\/ initialize lock to be FREE$/;"	p	class:Lock	access:public	signature:(char* debugName)
Lock	threads/synch.h	/^class Lock {$/;"	c
Lock::Acquire	threads/synch.cc	/^void Lock::Acquire() {}$/;"	f	class:Lock	signature:()
Lock::Acquire	threads/synch.h	/^    void Acquire(); \/\/ these are the only operations on a lock$/;"	p	class:Lock	access:public	signature:()
Lock::Lock	threads/synch.cc	/^Lock::Lock(char* debugName) {}$/;"	f	class:Lock	signature:(char* debugName)
Lock::Lock	threads/synch.h	/^    Lock(char* debugName);  		\/\/ initialize lock to be FREE$/;"	p	class:Lock	access:public	signature:(char* debugName)
Lock::Release	threads/synch.cc	/^void Lock::Release() {}$/;"	f	class:Lock	signature:()
Lock::Release	threads/synch.h	/^    void Release(); \/\/ they are both *atomic*$/;"	p	class:Lock	access:public	signature:()
Lock::getName	threads/synch.h	/^    char* getName() { return name; }	\/\/ debugging assist$/;"	f	class:Lock	access:public	signature:()
Lock::isHeldByCurrentThread	threads/synch.h	/^    bool isHeldByCurrentThread();	\/\/ true if the current thread$/;"	p	class:Lock	access:public	signature:()
Lock::name	threads/synch.h	/^    char* name;				\/\/ for debugging$/;"	m	class:Lock	access:private
Lock::~Lock	threads/synch.cc	/^Lock::~Lock() {}$/;"	f	class:Lock	signature:()
Lock::~Lock	threads/synch.h	/^    ~Lock();				\/\/ deallocate lock$/;"	p	class:Lock	access:public	signature:()
Lseek	machine/sysdep.cc	/^Lseek(int fd, int offset, int whence)$/;"	f	signature:(int fd, int offset, int whence)
Lseek	machine/sysdep.h	/^extern void Lseek(int fd, int offset, int whence);$/;"	p	signature:(int fd, int offset, int whence)
MACHINE_H	machine/machine.h	22;"	d
MAIN	bin/coff2flat.c	15;"	d	file:
MAIN	bin/coff2flat.c	17;"	d	file:
MAIN	bin/coff2noff.c	23;"	d	file:
MAIN	bin/coff2noff.c	25;"	d	file:
MAIN	bin/out.c	7;"	d	file:
MAIN	bin/out.c	9;"	d	file:
MAIN	threads/main.cc	49;"	d	file:
MAIN	threads/main.cc	51;"	d	file:
MAXDATA	bin/out.c	34;"	d	file:
MAXRELOCS	bin/out.c	31;"	d	file:
MAXSCNS	bin/out.c	43;"	d	file:
MAXSSPACE	bin/out.c	45;"	d	file:
MAXSYMS	bin/out.c	44;"	d	file:
MEMSIZE	bin/int.h	11;"	d
MIPSELMAGIC	bin/coff.h	15;"	d
MIPSSIM_H	machine/mipssim.h	11;"	d
Machine	machine/machine.cc	/^Machine::Machine(bool debug)$/;"	f	class:Machine	signature:(bool debug)
Machine	machine/machine.h	/^    Machine(bool debug);	\/\/ Initialize the simulation of the hardware$/;"	p	class:Machine	access:public	signature:(bool debug)
Machine	machine/machine.h	/^class Machine {$/;"	c
Machine::Debugger	machine/machine.cc	/^void Machine::Debugger()$/;"	f	class:Machine	signature:()
Machine::Debugger	machine/machine.h	/^    void Debugger();		\/\/ invoke the user program debugger$/;"	p	class:Machine	access:public	signature:()
Machine::DelayedLoad	machine/machine.h	/^    void DelayedLoad(int nextReg, int nextVal);  	$/;"	p	class:Machine	access:public	signature:(int nextReg, int nextVal)
Machine::DelayedLoad	machine/mipssim.cc	/^Machine::DelayedLoad(int nextReg, int nextValue)$/;"	f	class:Machine	signature:(int nextReg, int nextValue)
Machine::DumpState	machine/machine.cc	/^Machine::DumpState()$/;"	f	class:Machine	signature:()
Machine::DumpState	machine/machine.h	/^    void DumpState();		\/\/ print the user CPU and memory state $/;"	p	class:Machine	access:public	signature:()
Machine::Machine	machine/machine.cc	/^Machine::Machine(bool debug)$/;"	f	class:Machine	signature:(bool debug)
Machine::Machine	machine/machine.h	/^    Machine(bool debug);	\/\/ Initialize the simulation of the hardware$/;"	p	class:Machine	access:public	signature:(bool debug)
Machine::NachOSpageTable	machine/machine.h	/^    TranslationEntry *NachOSpageTable;$/;"	m	class:Machine	access:public
Machine::OneInstruction	machine/machine.h	/^    void OneInstruction(Instruction *instr); 	$/;"	p	class:Machine	access:public	signature:(Instruction *instr)
Machine::OneInstruction	machine/mipssim.cc	/^Machine::OneInstruction(Instruction *instr)$/;"	f	class:Machine	signature:(Instruction *instr)
Machine::RaiseException	machine/machine.cc	/^Machine::RaiseException(ExceptionType which, int badVAddr)$/;"	f	class:Machine	signature:(ExceptionType which, int badVAddr)
Machine::RaiseException	machine/machine.h	/^    void RaiseException(ExceptionType which, int badVAddr);$/;"	p	class:Machine	access:public	signature:(ExceptionType which, int badVAddr)
Machine::ReadMem	machine/machine.h	/^    bool ReadMem(int addr, int size, int* value);$/;"	p	class:Machine	access:public	signature:(int addr, int size, int* value)
Machine::ReadMem	machine/translate.cc	/^Machine::ReadMem(int addr, int size, int *value)$/;"	f	class:Machine	signature:(int addr, int size, int *value)
Machine::ReadRegister	machine/machine.cc	/^int Machine::ReadRegister(int num)$/;"	f	class:Machine	signature:(int num)
Machine::ReadRegister	machine/machine.h	/^    int ReadRegister(int num);	\/\/ read the contents of a CPU register$/;"	p	class:Machine	access:public	signature:(int num)
Machine::Run	machine/machine.h	/^    void Run();	 		\/\/ Run a user program$/;"	p	class:Machine	access:public	signature:()
Machine::Run	machine/mipssim.cc	/^Machine::Run()$/;"	f	class:Machine	signature:()
Machine::Translate	machine/machine.h	/^    ExceptionType Translate(int virtAddr, int* physAddr, int size,bool writing);$/;"	p	class:Machine	access:public	signature:(int virtAddr, int* physAddr, int size,bool writing)
Machine::Translate	machine/translate.cc	/^Machine::Translate(int virtAddr, int* physAddr, int size, bool writing)$/;"	f	class:Machine	signature:(int virtAddr, int* physAddr, int size, bool writing)
Machine::WriteMem	machine/machine.h	/^    bool WriteMem(int addr, int size, int value);$/;"	p	class:Machine	access:public	signature:(int addr, int size, int value)
Machine::WriteMem	machine/translate.cc	/^Machine::WriteMem(int addr, int size, int value)$/;"	f	class:Machine	signature:(int addr, int size, int value)
Machine::WriteRegister	machine/machine.cc	/^void Machine::WriteRegister(int num, int value)$/;"	f	class:Machine	signature:(int num, int value)
Machine::WriteRegister	machine/machine.h	/^    void WriteRegister(int num, int value);$/;"	p	class:Machine	access:public	signature:(int num, int value)
Machine::mainMemory	machine/machine.h	/^    char *mainMemory;		\/\/ physical memory to store user program,$/;"	m	class:Machine	access:public
Machine::pageTableSize	machine/machine.h	/^    unsigned int pageTableSize;$/;"	m	class:Machine	access:public
Machine::registers	machine/machine.h	/^    int registers[NumTotalRegs]; \/\/ CPU registers, for executing user programs$/;"	m	class:Machine	access:public
Machine::runUntilTime	machine/machine.h	/^    int runUntilTime;		\/\/ drop back into the debugger when simulated$/;"	m	class:Machine	access:private
Machine::singleStep	machine/machine.h	/^    bool singleStep;		\/\/ drop back into the debugger after each$/;"	m	class:Machine	access:private
Machine::tlb	machine/machine.h	/^    TranslationEntry *tlb;		\/\/ this pointer should be considered $/;"	m	class:Machine	access:public
Machine::~Machine	machine/machine.cc	/^Machine::~Machine()$/;"	f	class:Machine	signature:()
Machine::~Machine	machine/machine.h	/^    ~Machine();			\/\/ De-allocate the data structures$/;"	p	class:Machine	access:public	signature:()
MachineStateSize	threads/thread.h	51;"	d
MachineStatus	machine/interrupt.h	/^enum MachineStatus {IdleMode, SystemMode, UserMode};$/;"	g
MagicNumber	machine/disk.cc	23;"	d	file:
MagicSize	machine/disk.cc	24;"	d	file:
Mail	network/post.cc	/^Mail::Mail(PacketHeader pktH, MailHeader mailH, char *msgData)$/;"	f	class:Mail	signature:(PacketHeader pktH, MailHeader mailH, char *msgData)
Mail	network/post.h	/^     Mail(PacketHeader pktH, MailHeader mailH, char *msgData);$/;"	p	class:Mail	access:public	signature:(PacketHeader pktH, MailHeader mailH, char *msgData)
Mail	network/post.h	/^class Mail {$/;"	c
Mail::Mail	network/post.cc	/^Mail::Mail(PacketHeader pktH, MailHeader mailH, char *msgData)$/;"	f	class:Mail	signature:(PacketHeader pktH, MailHeader mailH, char *msgData)
Mail::Mail	network/post.h	/^     Mail(PacketHeader pktH, MailHeader mailH, char *msgData);$/;"	p	class:Mail	access:public	signature:(PacketHeader pktH, MailHeader mailH, char *msgData)
Mail::data	network/post.h	/^     char data[MaxMailSize];	\/\/ Payload -- message data$/;"	m	class:Mail	access:public
Mail::mailHdr	network/post.h	/^     MailHeader mailHdr;	\/\/ Header appended by PostOffice$/;"	m	class:Mail	access:public
Mail::pktHdr	network/post.h	/^     PacketHeader pktHdr;	\/\/ Header appended by Network$/;"	m	class:Mail	access:public
MailBox	network/post.cc	/^MailBox::MailBox()$/;"	f	class:MailBox	signature:()
MailBox	network/post.h	/^    MailBox();			\/\/ Allocate and initialize mail box$/;"	p	class:MailBox	access:public	signature:()
MailBox	network/post.h	/^class MailBox {$/;"	c
MailBox::Get	network/post.cc	/^MailBox::Get(PacketHeader *pktHdr, MailHeader *mailHdr, char *data) $/;"	f	class:MailBox	signature:(PacketHeader *pktHdr, MailHeader *mailHdr, char *data)
MailBox::Get	network/post.h	/^    void Get(PacketHeader *pktHdr, MailHeader *mailHdr, char *data); $/;"	p	class:MailBox	access:public	signature:(PacketHeader *pktHdr, MailHeader *mailHdr, char *data)
MailBox::MailBox	network/post.cc	/^MailBox::MailBox()$/;"	f	class:MailBox	signature:()
MailBox::MailBox	network/post.h	/^    MailBox();			\/\/ Allocate and initialize mail box$/;"	p	class:MailBox	access:public	signature:()
MailBox::Put	network/post.cc	/^MailBox::Put(PacketHeader pktHdr, MailHeader mailHdr, char *data)$/;"	f	class:MailBox	signature:(PacketHeader pktHdr, MailHeader mailHdr, char *data)
MailBox::Put	network/post.h	/^    void Put(PacketHeader pktHdr, MailHeader mailHdr, char *data);$/;"	p	class:MailBox	access:public	signature:(PacketHeader pktHdr, MailHeader mailHdr, char *data)
MailBox::messages	network/post.h	/^    SynchList *messages;	\/\/ A mailbox is just a list of arrived messages$/;"	m	class:MailBox	access:private
MailBox::~MailBox	network/post.cc	/^MailBox::~MailBox()$/;"	f	class:MailBox	signature:()
MailBox::~MailBox	network/post.h	/^    ~MailBox();			\/\/ De-allocate mail box$/;"	p	class:MailBox	access:public	signature:()
MailBoxAddress	network/post.h	/^typedef int MailBoxAddress;$/;"	t
MailHeader	network/post.h	/^class MailHeader {$/;"	c
MailHeader::from	network/post.h	/^    MailBoxAddress from;	\/\/ Mail box to reply to$/;"	m	class:MailHeader	access:public
MailHeader::length	network/post.h	/^    unsigned length;		\/\/ Bytes of message data (excluding the $/;"	m	class:MailHeader	access:public
MailHeader::to	network/post.h	/^    MailBoxAddress to;		\/\/ Destination mail box$/;"	m	class:MailHeader	access:public
MailTest	network/nettest.cc	/^MailTest(int farAddr)$/;"	f	signature:(int farAddr)
MailTest	threads/main.cc	/^extern void MailTest(int networkID);$/;"	p	file:	signature:(int networkID)
Mapcar	threads/list.cc	/^List::Mapcar(VoidFunctionPtr func)$/;"	f	class:List	signature:(VoidFunctionPtr func)
Mapcar	threads/list.h	/^    void Mapcar(VoidFunctionPtr func);	\/\/ Apply "func" to every element $/;"	p	class:List	access:public	signature:(VoidFunctionPtr func)
Mapcar	threads/synchlist.cc	/^SynchList::Mapcar(VoidFunctionPtr func)$/;"	f	class:SynchList	signature:(VoidFunctionPtr func)
Mapcar	threads/synchlist.h	/^    void Mapcar(VoidFunctionPtr func);$/;"	p	class:SynchList	access:public	signature:(VoidFunctionPtr func)
Mark	userprog/bitmap.cc	/^BitMap::Mark(int which) $/;"	f	class:BitMap	signature:(int which)
Mark	userprog/bitmap.h	/^    void Mark(int which);   	\/\/ Set the "nth" bit$/;"	p	class:BitMap	access:public	signature:(int which)
MaxFileSize	filesys/filehdr.h	21;"	d
MaxMailSize	network/post.h	53;"	d
MaxOpcode	machine/mipssim.h	88;"	d
MaxPacketSize	machine/network.h	41;"	d
MaxWireSize	machine/network.h	40;"	d
MemorySize	machine/machine.h	36;"	d
ModuloDiff	machine/disk.cc	/^Disk::ModuloDiff(int to, int from)$/;"	f	class:Disk	signature:(int to, int from)
ModuloDiff	machine/disk.h	/^    int ModuloDiff(int to, int from);        \/\/ # sectors between to and from$/;"	p	class:Disk	access:private	signature:(int to, int from)
Mult	machine/mipssim.cc	/^Mult(int a, int b, bool signedArith, int* hiPtr, int* loPtr)$/;"	f	file:	signature:(int a, int b, bool signedArith, int* hiPtr, int* loPtr)
Mult	machine/mipssim.cc	/^static void Mult(int a, int b, bool signedArith, int* hiPtr, int* loPtr);$/;"	p	file:	signature:(int a, int b, bool signedArith, int* hiPtr, int* loPtr)
NETWORK_H	machine/network.h	16;"	d
NH	bin/execute.c	465;"	d	file:
NNN	bin/execute.c	466;"	d	file:
NNNN	bin/execute.c	555;"	d	file:
NOFFMAGIC	bin/noff.h	8;"	d
NONE	machine/mipssim.h	/^enum RegType { NONE, RS, RT, RD, EXTRA }; $/;"	e	enum:RegType
NROWS	bin/disasm.c	/^int NROWS=64, ASSOC=1, LINESIZE=4, RAND=0, LRD=0;$/;"	v
NROWS	bin/main.c	/^int NROWS=64, ASSOC=1, LINESIZE=4, RAND=0, LRD=0;$/;"	v
NULL	bin/d.c	11;"	d	file:
NachOSThread	threads/thread.cc	/^NachOSThread::NachOSThread(char* threadName)$/;"	f	class:NachOSThread	signature:(char* threadName)
NachOSThread	threads/thread.h	/^    NachOSThread(char* debugName);		\/\/ initialize a Thread $/;"	p	class:NachOSThread	access:public	signature:(char* debugName)
NachOSThread	threads/thread.h	/^class NachOSThread {$/;"	c
NachOSThread::AllocateThreadStack	threads/thread.cc	/^NachOSThread::AllocateThreadStack (VoidFunctionPtr func, int arg)$/;"	f	class:NachOSThread	signature:(VoidFunctionPtr func, int arg)
NachOSThread::AllocateThreadStack	threads/thread.h	/^    void AllocateThreadStack(VoidFunctionPtr func, int arg);$/;"	p	class:NachOSThread	access:private	signature:(VoidFunctionPtr func, int arg)
NachOSThread::CheckOverflow	threads/thread.cc	/^NachOSThread::CheckOverflow()$/;"	f	class:NachOSThread	signature:()
NachOSThread::CheckOverflow	threads/thread.h	/^    void CheckOverflow();   			\/\/ Check if thread has $/;"	p	class:NachOSThread	access:public	signature:()
NachOSThread::FinishThread	threads/thread.cc	/^NachOSThread::FinishThread ()$/;"	f	class:NachOSThread	signature:()
NachOSThread::FinishThread	threads/thread.h	/^    void FinishThread();  				\/\/ The thread is done executing$/;"	p	class:NachOSThread	access:public	signature:()
NachOSThread::NachOSThread	threads/thread.cc	/^NachOSThread::NachOSThread(char* threadName)$/;"	f	class:NachOSThread	signature:(char* threadName)
NachOSThread::NachOSThread	threads/thread.h	/^    NachOSThread(char* debugName);		\/\/ initialize a Thread $/;"	p	class:NachOSThread	access:public	signature:(char* debugName)
NachOSThread::Print	threads/thread.h	/^    void Print() { printf("%s, ", name); }$/;"	f	class:NachOSThread	access:public	signature:()
NachOSThread::PutThreadToSleep	threads/thread.cc	/^NachOSThread::PutThreadToSleep ()$/;"	f	class:NachOSThread	signature:()
NachOSThread::PutThreadToSleep	threads/thread.h	/^    void PutThreadToSleep();  				\/\/ Put the thread to sleep and $/;"	p	class:NachOSThread	access:public	signature:()
NachOSThread::RestoreUserState	threads/thread.cc	/^NachOSThread::RestoreUserState()$/;"	f	class:NachOSThread	signature:()
NachOSThread::RestoreUserState	threads/thread.h	/^    void RestoreUserState();		\/\/ restore user-level register state$/;"	p	class:NachOSThread	access:public	signature:()
NachOSThread::SaveUserState	threads/thread.cc	/^NachOSThread::SaveUserState()$/;"	f	class:NachOSThread	signature:()
NachOSThread::SaveUserState	threads/thread.h	/^    void SaveUserState();		\/\/ save user-level register state$/;"	p	class:NachOSThread	access:public	signature:()
NachOSThread::ThreadFork	threads/thread.cc	/^NachOSThread::ThreadFork(VoidFunctionPtr func, int arg)$/;"	f	class:NachOSThread	signature:(VoidFunctionPtr func, int arg)
NachOSThread::ThreadFork	threads/thread.h	/^    void ThreadFork(VoidFunctionPtr func, int arg); 	\/\/ Make thread run (*func)(arg)$/;"	p	class:NachOSThread	access:public	signature:(VoidFunctionPtr func, int arg)
NachOSThread::YieldCPU	threads/thread.cc	/^NachOSThread::YieldCPU ()$/;"	f	class:NachOSThread	signature:()
NachOSThread::YieldCPU	threads/thread.h	/^    void YieldCPU();  				\/\/ Relinquish the CPU if any $/;"	p	class:NachOSThread	access:public	signature:()
NachOSThread::getName	threads/thread.h	/^    char* getName() { return (name); }$/;"	f	class:NachOSThread	access:public	signature:()
NachOSThread::getNumInstr	threads/thread.h	/^    int getNumInstr() { return numInstr; }$/;"	f	class:NachOSThread	access:public	signature:()
NachOSThread::getPID	threads/thread.h	/^    int getPID() { return pid; }$/;"	f	class:NachOSThread	access:public	signature:()
NachOSThread::getPPID	threads/thread.h	/^    int getPPID() { return ppid; }$/;"	f	class:NachOSThread	access:public	signature:()
NachOSThread::incNumInstr	threads/thread.h	/^    void incNumInstr() { numInstr++; }$/;"	f	class:NachOSThread	access:public	signature:()
NachOSThread::machineState	threads/thread.h	/^    int machineState[MachineStateSize];  \/\/ all registers except for stackTop$/;"	m	class:NachOSThread	access:private
NachOSThread::name	threads/thread.h	/^    char* name;$/;"	m	class:NachOSThread	access:private
NachOSThread::numInstr	threads/thread.h	/^    int numInstr;$/;"	m	class:NachOSThread	access:private
NachOSThread::pid	threads/thread.h	/^    int pid, ppid;			\/\/ My pid and my parent's pid$/;"	m	class:NachOSThread	access:private
NachOSThread::ppid	threads/thread.h	/^    int pid, ppid;			\/\/ My pid and my parent's pid$/;"	m	class:NachOSThread	access:private
NachOSThread::prpid	threads/system.cc	/^int NachOSThread::prpid = -1;$/;"	m	class:NachOSThread	file:
NachOSThread::prpid	threads/thread.h	/^    static int prpid;$/;"	m	class:NachOSThread	access:public
NachOSThread::setPID	threads/thread.h	/^    void setPID() { this->pid = prpid + 1; prpid = pid;}$/;"	f	class:NachOSThread	access:public	signature:()
NachOSThread::setPPID	threads/thread.h	/^    void setPPID(int ppid) { this->ppid = ppid; }$/;"	f	class:NachOSThread	access:public	signature:(int ppid)
NachOSThread::setStatus	threads/thread.h	/^    void setStatus(ThreadStatus st) { status = st; }$/;"	f	class:NachOSThread	access:public	signature:(ThreadStatus st)
NachOSThread::space	threads/thread.h	/^    ProcessAddrSpace *space;			\/\/ User code this thread is running.$/;"	m	class:NachOSThread	access:public
NachOSThread::stack	threads/thread.h	/^    int* stack; 	 		\/\/ Bottom of the stack $/;"	m	class:NachOSThread	access:private
NachOSThread::stackTop	threads/thread.h	/^    int* stackTop;			 \/\/ the current stack pointer$/;"	m	class:NachOSThread	access:private
NachOSThread::status	threads/thread.h	/^    ThreadStatus status;		\/\/ ready, running or blocked$/;"	m	class:NachOSThread	access:private
NachOSThread::userRegisters	threads/thread.h	/^    int userRegisters[NumTotalRegs];	\/\/ user-level CPU register state$/;"	m	class:NachOSThread	access:private
NachOSThread::~NachOSThread	threads/thread.cc	/^NachOSThread::~NachOSThread()$/;"	f	class:NachOSThread	signature:()
NachOSThread::~NachOSThread	threads/thread.h	/^    ~NachOSThread(); 				\/\/ deallocate a Thread$/;"	p	class:NachOSThread	access:public	signature:()
NachOSpageTable	machine/machine.h	/^    TranslationEntry *NachOSpageTable;$/;"	m	class:Machine	access:public
NachOSpageTable	userprog/addrspace.h	/^    TranslationEntry *NachOSpageTable;	\/\/ Assume linear page table translation$/;"	m	class:ProcessAddrSpace	access:private
NachOSscheduler	threads/scheduler.cc	/^NachOSscheduler::NachOSscheduler()$/;"	f	class:NachOSscheduler	signature:()
NachOSscheduler	threads/scheduler.h	/^    NachOSscheduler();			\/\/ Initialize list of ready threads $/;"	p	class:NachOSscheduler	access:public	signature:()
NachOSscheduler	threads/scheduler.h	/^class NachOSscheduler {$/;"	c
NachOSscheduler::FindNextThreadToRun	threads/scheduler.cc	/^NachOSscheduler::FindNextThreadToRun ()$/;"	f	class:NachOSscheduler	signature:()
NachOSscheduler::FindNextThreadToRun	threads/scheduler.h	/^    NachOSThread* FindNextThreadToRun();		\/\/ Dequeue first thread on the ready $/;"	p	class:NachOSscheduler	access:public	signature:()
NachOSscheduler::NachOSscheduler	threads/scheduler.cc	/^NachOSscheduler::NachOSscheduler()$/;"	f	class:NachOSscheduler	signature:()
NachOSscheduler::NachOSscheduler	threads/scheduler.h	/^    NachOSscheduler();			\/\/ Initialize list of ready threads $/;"	p	class:NachOSscheduler	access:public	signature:()
NachOSscheduler::Print	threads/scheduler.cc	/^NachOSscheduler::Print()$/;"	f	class:NachOSscheduler	signature:()
NachOSscheduler::Print	threads/scheduler.h	/^    void Print();			\/\/ Print contents of ready list$/;"	p	class:NachOSscheduler	access:public	signature:()
NachOSscheduler::RemoveFromSleep	threads/scheduler.cc	/^NachOSscheduler::RemoveFromSleep (int *keyPtr){$/;"	f	class:NachOSscheduler	signature:(int *keyPtr)
NachOSscheduler::RemoveFromSleep	threads/scheduler.h	/^    void *RemoveFromSleep(int *keyPtr);$/;"	p	class:NachOSscheduler	access:public	signature:(int *keyPtr)
NachOSscheduler::Schedule	threads/scheduler.cc	/^NachOSscheduler::Schedule (NachOSThread *nextThread)$/;"	f	class:NachOSscheduler	signature:(NachOSThread *nextThread)
NachOSscheduler::Schedule	threads/scheduler.h	/^    void Schedule(NachOSThread* nextThread);	\/\/ Cause nextThread to start running$/;"	p	class:NachOSscheduler	access:public	signature:(NachOSThread* nextThread)
NachOSscheduler::ThreadIsReadyToRun	threads/scheduler.cc	/^NachOSscheduler::ThreadIsReadyToRun (NachOSThread *thread)$/;"	f	class:NachOSscheduler	signature:(NachOSThread *thread)
NachOSscheduler::ThreadIsReadyToRun	threads/scheduler.h	/^    void ThreadIsReadyToRun(NachOSThread* thread);	\/\/ Thread can be dispatched.$/;"	p	class:NachOSscheduler	access:public	signature:(NachOSThread* thread)
NachOSscheduler::ThreadIsReadyToSleep	threads/scheduler.cc	/^NachOSscheduler::ThreadIsReadyToSleep (NachOSThread *thread, int ticks)$/;"	f	class:NachOSscheduler	signature:(NachOSThread *thread, int ticks)
NachOSscheduler::ThreadIsReadyToSleep	threads/scheduler.h	/^    void ThreadIsReadyToSleep(NachOSThread* thread, int ticks);$/;"	p	class:NachOSscheduler	access:public	signature:(NachOSThread* thread, int ticks)
NachOSscheduler::readyThreadList	threads/scheduler.h	/^    List *readyThreadList;  		\/\/ queue of threads that are ready to run,$/;"	m	class:NachOSscheduler	access:private
NachOSscheduler::sleepThreadList	threads/scheduler.h	/^    List *sleepThreadList;$/;"	m	class:NachOSscheduler	access:private
NachOSscheduler::~NachOSscheduler	threads/scheduler.cc	/^NachOSscheduler::~NachOSscheduler()$/;"	f	class:NachOSscheduler	signature:()
NachOSscheduler::~NachOSscheduler	threads/scheduler.h	/^    ~NachOSscheduler();			\/\/ De-allocate ready list$/;"	p	class:NachOSscheduler	access:public	signature:()
Network	machine/network.cc	/^Network::Network(NetworkAddress addr, double reliability,$/;"	f	class:Network	signature:(NetworkAddress addr, double reliability, VoidFunctionPtr readAvail, VoidFunctionPtr writeDone, int callArg)
Network	machine/network.h	/^    Network(NetworkAddress addr, double reliability,$/;"	p	class:Network	access:public	signature:(NetworkAddress addr, double reliability, VoidFunctionPtr readAvail, VoidFunctionPtr writeDone, int callArg)
Network	machine/network.h	/^class Network {$/;"	c
Network::CheckPktAvail	machine/network.cc	/^Network::CheckPktAvail()$/;"	f	class:Network	signature:()
Network::CheckPktAvail	machine/network.h	/^    void CheckPktAvail();	\/\/ Check if there is an incoming packet$/;"	p	class:Network	access:public	signature:()
Network::Network	machine/network.cc	/^Network::Network(NetworkAddress addr, double reliability,$/;"	f	class:Network	signature:(NetworkAddress addr, double reliability, VoidFunctionPtr readAvail, VoidFunctionPtr writeDone, int callArg)
Network::Network	machine/network.h	/^    Network(NetworkAddress addr, double reliability,$/;"	p	class:Network	access:public	signature:(NetworkAddress addr, double reliability, VoidFunctionPtr readAvail, VoidFunctionPtr writeDone, int callArg)
Network::Receive	machine/network.cc	/^Network::Receive(char* data)$/;"	f	class:Network	signature:(char* data)
Network::Receive	machine/network.h	/^    PacketHeader Receive(char* data);$/;"	p	class:Network	access:public	signature:(char* data)
Network::Send	machine/network.cc	/^Network::Send(PacketHeader hdr, char* data)$/;"	f	class:Network	signature:(PacketHeader hdr, char* data)
Network::Send	machine/network.h	/^    void Send(PacketHeader hdr, char* data);$/;"	p	class:Network	access:public	signature:(PacketHeader hdr, char* data)
Network::SendDone	machine/network.cc	/^Network::SendDone()$/;"	f	class:Network	signature:()
Network::SendDone	machine/network.h	/^    void SendDone();		\/\/ Interrupt handler, called when message is $/;"	p	class:Network	access:public	signature:()
Network::chanceToWork	machine/network.h	/^    double chanceToWork;	\/\/ Likelihood packet will be dropped$/;"	m	class:Network	access:private
Network::handlerArg	machine/network.h	/^    int handlerArg;		\/\/ Argument to be passed to interrupt handler$/;"	m	class:Network	access:private
Network::ident	machine/network.h	/^    NetworkAddress ident;	\/\/ This machine's network address$/;"	m	class:Network	access:private
Network::inHdr	machine/network.h	/^    PacketHeader inHdr;		\/\/ Information about arrived packet$/;"	m	class:Network	access:private
Network::inbox	machine/network.h	/^    char inbox[MaxPacketSize];  \/\/ Data for arrived packet$/;"	m	class:Network	access:private
Network::packetAvail	machine/network.h	/^    bool packetAvail;		\/\/ Packet has arrived, can be pulled off of$/;"	m	class:Network	access:private
Network::readHandler	machine/network.h	/^    VoidFunctionPtr readHandler;  \/\/ Interrupt handler, signalling packet has $/;"	m	class:Network	access:private
Network::sendBusy	machine/network.h	/^    bool sendBusy;		\/\/ Packet is being sent.$/;"	m	class:Network	access:private
Network::sock	machine/network.h	/^    int sock;			\/\/ UNIX socket number for incoming packets$/;"	m	class:Network	access:private
Network::sockName	machine/network.h	/^    char sockName[32];		\/\/ File name corresponding to UNIX socket$/;"	m	class:Network	access:private
Network::writeHandler	machine/network.h	/^    VoidFunctionPtr writeHandler; \/\/ Interrupt handler, signalling next packet $/;"	m	class:Network	access:private
Network::~Network	machine/network.cc	/^Network::~Network()$/;"	f	class:Network	signature:()
Network::~Network	machine/network.h	/^    ~Network();			\/\/ De-allocate the network driver data$/;"	p	class:Network	access:public	signature:()
NetworkAddress	machine/network.h	/^typedef int NetworkAddress;	 $/;"	t
NetworkReadPoll	machine/network.cc	/^static void NetworkReadPoll(int arg)$/;"	f	file:	signature:(int arg)
NetworkRecvInt	machine/interrupt.h	/^				NetworkSendInt, NetworkRecvInt};$/;"	e	enum:IntType
NetworkSendDone	machine/network.cc	/^static void NetworkSendDone(int arg)$/;"	f	file:	signature:(int arg)
NetworkSendInt	machine/interrupt.h	/^				NetworkSendInt, NetworkRecvInt};$/;"	e	enum:IntType
NetworkTime	machine/stats.h	57;"	d
NextPCReg	machine/machine.h	66;"	d
NoException	machine/machine.h	/^enum ExceptionType { NoException,           \/\/ Everything ok!$/;"	e	enum:ExceptionType
NoffHeader	bin/noff.h	/^} NoffHeader;$/;"	t	typeref:struct:noffHeader
NumClear	userprog/bitmap.cc	/^BitMap::NumClear() $/;"	f	class:BitMap	signature:()
NumClear	userprog/bitmap.h	/^    int NumClear();		\/\/ Return the number of clear bits$/;"	p	class:BitMap	access:public	signature:()
NumDirEntries	filesys/filesys.cc	64;"	d	file:
NumDirect	filesys/filehdr.h	20;"	d
NumExceptionTypes	machine/machine.h	/^		     NumExceptionTypes$/;"	e	enum:ExceptionType
NumGPRegs	machine/machine.h	62;"	d
NumPhysPages	machine/machine.h	35;"	d
NumSectors	machine/disk.h	52;"	d
NumTotalRegs	machine/machine.h	72;"	d
NumTracks	machine/disk.h	51;"	d
OMAGIC	bin/coff.h	17;"	d
OPENFILE_H	filesys/openfile.h	21;"	d
OP_ADD	machine/mipssim.h	25;"	d
OP_ADDI	machine/mipssim.h	26;"	d
OP_ADDIU	machine/mipssim.h	27;"	d
OP_ADDU	machine/mipssim.h	28;"	d
OP_AND	machine/mipssim.h	29;"	d
OP_ANDI	machine/mipssim.h	30;"	d
OP_BEQ	machine/mipssim.h	31;"	d
OP_BGEZ	machine/mipssim.h	32;"	d
OP_BGEZAL	machine/mipssim.h	33;"	d
OP_BGTZ	machine/mipssim.h	34;"	d
OP_BLEZ	machine/mipssim.h	35;"	d
OP_BLTZ	machine/mipssim.h	36;"	d
OP_BLTZAL	machine/mipssim.h	37;"	d
OP_BNE	machine/mipssim.h	38;"	d
OP_DIV	machine/mipssim.h	40;"	d
OP_DIVU	machine/mipssim.h	41;"	d
OP_J	machine/mipssim.h	42;"	d
OP_JAL	machine/mipssim.h	43;"	d
OP_JALR	machine/mipssim.h	44;"	d
OP_JR	machine/mipssim.h	45;"	d
OP_LB	machine/mipssim.h	46;"	d
OP_LBU	machine/mipssim.h	47;"	d
OP_LH	machine/mipssim.h	48;"	d
OP_LHU	machine/mipssim.h	49;"	d
OP_LUI	machine/mipssim.h	50;"	d
OP_LW	machine/mipssim.h	51;"	d
OP_LWL	machine/mipssim.h	52;"	d
OP_LWR	machine/mipssim.h	53;"	d
OP_MFHI	machine/mipssim.h	55;"	d
OP_MFLO	machine/mipssim.h	56;"	d
OP_MTHI	machine/mipssim.h	58;"	d
OP_MTLO	machine/mipssim.h	59;"	d
OP_MULT	machine/mipssim.h	60;"	d
OP_MULTU	machine/mipssim.h	61;"	d
OP_NOR	machine/mipssim.h	62;"	d
OP_OR	machine/mipssim.h	63;"	d
OP_ORI	machine/mipssim.h	64;"	d
OP_RES	machine/mipssim.h	87;"	d
OP_RFE	machine/mipssim.h	65;"	d
OP_SB	machine/mipssim.h	66;"	d
OP_SH	machine/mipssim.h	67;"	d
OP_SLL	machine/mipssim.h	68;"	d
OP_SLLV	machine/mipssim.h	69;"	d
OP_SLT	machine/mipssim.h	70;"	d
OP_SLTI	machine/mipssim.h	71;"	d
OP_SLTIU	machine/mipssim.h	72;"	d
OP_SLTU	machine/mipssim.h	73;"	d
OP_SRA	machine/mipssim.h	74;"	d
OP_SRAV	machine/mipssim.h	75;"	d
OP_SRL	machine/mipssim.h	76;"	d
OP_SRLV	machine/mipssim.h	77;"	d
OP_SUB	machine/mipssim.h	78;"	d
OP_SUBU	machine/mipssim.h	79;"	d
OP_SW	machine/mipssim.h	80;"	d
OP_SWL	machine/mipssim.h	81;"	d
OP_SWR	machine/mipssim.h	82;"	d
OP_SYSCALL	machine/mipssim.h	85;"	d
OP_UNIMP	machine/mipssim.h	86;"	d
OP_XOR	machine/mipssim.h	83;"	d
OP_XORI	machine/mipssim.h	84;"	d
OneInstruction	machine/machine.h	/^    void OneInstruction(Instruction *instr); 	$/;"	p	class:Machine	access:public	signature:(Instruction *instr)
OneInstruction	machine/mipssim.cc	/^Machine::OneInstruction(Instruction *instr)$/;"	f	class:Machine	signature:(Instruction *instr)
OneTick	machine/interrupt.cc	/^Interrupt::OneTick()$/;"	f	class:Interrupt	signature:()
OneTick	machine/interrupt.h	/^    void OneTick();       		\/\/ Advance simulated time$/;"	p	class:Interrupt	access:public	signature:()
OpInfo	machine/mipssim.h	/^struct OpInfo {$/;"	s
OpInfo::format	machine/mipssim.h	/^    int format;		\/* Format type (IFMT or JFMT or RFMT) *\/$/;"	m	struct:OpInfo	access:public
OpInfo::opCode	machine/mipssim.h	/^    int opCode;		\/* Translated op code. *\/$/;"	m	struct:OpInfo	access:public
OpString	machine/mipssim.h	/^struct OpString {$/;"	s
OpString::args	machine/mipssim.h	/^    RegType args[3];$/;"	m	struct:OpString	access:public
OpString::string	machine/mipssim.h	/^    char *string;	\/\/ Printed version of instruction$/;"	m	struct:OpString	access:public
Open	filesys/filesys.cc	/^FileSystem::Open(char *name)$/;"	f	class:FileSystem	signature:(char *name)
Open	filesys/filesys.h	/^    OpenFile* Open(char *name) {$/;"	f	class:FileSystem	access:public	signature:(char *name)
Open	filesys/filesys.h	/^    OpenFile* Open(char *name); 	\/\/ Open a file (UNIX open)$/;"	p	class:FileSystem	access:public	signature:(char *name)
OpenFile	filesys/openfile.cc	/^OpenFile::OpenFile(int sector)$/;"	f	class:OpenFile	signature:(int sector)
OpenFile	filesys/openfile.h	/^    OpenFile(int f) { file = f; currentOffset = 0; }	\/\/ open the file$/;"	f	class:OpenFile	access:public	signature:(int f)
OpenFile	filesys/openfile.h	/^    OpenFile(int sector);		\/\/ Open a file whose header is located$/;"	p	class:OpenFile	access:public	signature:(int sector)
OpenFile	filesys/openfile.h	/^class OpenFile {$/;"	c
OpenFile::Length	filesys/openfile.cc	/^OpenFile::Length() $/;"	f	class:OpenFile	signature:()
OpenFile::Length	filesys/openfile.h	/^    int Length() { Lseek(file, 0, 2); return Tell(file); }$/;"	f	class:OpenFile	access:public	signature:()
OpenFile::Length	filesys/openfile.h	/^    int Length(); 			\/\/ Return the number of bytes in the$/;"	p	class:OpenFile	access:public	signature:()
OpenFile::OpenFile	filesys/openfile.cc	/^OpenFile::OpenFile(int sector)$/;"	f	class:OpenFile	signature:(int sector)
OpenFile::OpenFile	filesys/openfile.h	/^    OpenFile(int f) { file = f; currentOffset = 0; }	\/\/ open the file$/;"	f	class:OpenFile	access:public	signature:(int f)
OpenFile::OpenFile	filesys/openfile.h	/^    OpenFile(int sector);		\/\/ Open a file whose header is located$/;"	p	class:OpenFile	access:public	signature:(int sector)
OpenFile::Read	filesys/openfile.cc	/^OpenFile::Read(char *into, int numBytes)$/;"	f	class:OpenFile	signature:(char *into, int numBytes)
OpenFile::Read	filesys/openfile.h	/^    int Read(char *into, int numBytes) {$/;"	f	class:OpenFile	access:public	signature:(char *into, int numBytes)
OpenFile::Read	filesys/openfile.h	/^    int Read(char *into, int numBytes); \/\/ Read\/write bytes from the file,$/;"	p	class:OpenFile	access:public	signature:(char *into, int numBytes)
OpenFile::ReadAt	filesys/openfile.cc	/^OpenFile::ReadAt(char *into, int numBytes, int position)$/;"	f	class:OpenFile	signature:(char *into, int numBytes, int position)
OpenFile::ReadAt	filesys/openfile.h	/^    int ReadAt(char *into, int numBytes, int position) { $/;"	f	class:OpenFile	access:public	signature:(char *into, int numBytes, int position)
OpenFile::ReadAt	filesys/openfile.h	/^    int ReadAt(char *into, int numBytes, int position);$/;"	p	class:OpenFile	access:public	signature:(char *into, int numBytes, int position)
OpenFile::Seek	filesys/openfile.cc	/^OpenFile::Seek(int position)$/;"	f	class:OpenFile	signature:(int position)
OpenFile::Seek	filesys/openfile.h	/^    void Seek(int position); 		\/\/ Set the position from which to $/;"	p	class:OpenFile	access:public	signature:(int position)
OpenFile::Write	filesys/openfile.cc	/^OpenFile::Write(char *into, int numBytes)$/;"	f	class:OpenFile	signature:(char *into, int numBytes)
OpenFile::Write	filesys/openfile.h	/^    int Write(char *from, int numBytes) {$/;"	f	class:OpenFile	access:public	signature:(char *from, int numBytes)
OpenFile::Write	filesys/openfile.h	/^    int Write(char *from, int numBytes);$/;"	p	class:OpenFile	access:public	signature:(char *from, int numBytes)
OpenFile::WriteAt	filesys/openfile.cc	/^OpenFile::WriteAt(char *from, int numBytes, int position)$/;"	f	class:OpenFile	signature:(char *from, int numBytes, int position)
OpenFile::WriteAt	filesys/openfile.h	/^    int WriteAt(char *from, int numBytes, int position) { $/;"	f	class:OpenFile	access:public	signature:(char *from, int numBytes, int position)
OpenFile::WriteAt	filesys/openfile.h	/^    int WriteAt(char *from, int numBytes, int position);$/;"	p	class:OpenFile	access:public	signature:(char *from, int numBytes, int position)
OpenFile::currentOffset	filesys/openfile.h	/^    int currentOffset;$/;"	m	class:OpenFile	access:private
OpenFile::file	filesys/openfile.h	/^    int file;$/;"	m	class:OpenFile	access:private
OpenFile::hdr	filesys/openfile.h	/^    FileHeader *hdr;			\/\/ Header for this file $/;"	m	class:OpenFile	access:private
OpenFile::seekPosition	filesys/openfile.h	/^    int seekPosition;			\/\/ Current position within the file$/;"	m	class:OpenFile	access:private
OpenFile::~OpenFile	filesys/openfile.cc	/^OpenFile::~OpenFile()$/;"	f	class:OpenFile	signature:()
OpenFile::~OpenFile	filesys/openfile.h	/^    ~OpenFile() { Close(file); }			\/\/ close the file$/;"	f	class:OpenFile	access:public	signature:()
OpenFile::~OpenFile	filesys/openfile.h	/^    ~OpenFile();			\/\/ Close the file$/;"	p	class:OpenFile	access:public	signature:()
OpenFileId	userprog/syscall.h	/^typedef int OpenFileId;	$/;"	t
OpenForReadWrite	machine/sysdep.cc	/^OpenForReadWrite(char *name, bool crashOnError)$/;"	f	signature:(char *name, bool crashOnError)
OpenForReadWrite	machine/sysdep.h	/^extern int OpenForReadWrite(char *name, bool crashOnError);$/;"	p	signature:(char *name, bool crashOnError)
OpenForWrite	machine/sysdep.cc	/^OpenForWrite(char *name)$/;"	f	signature:(char *name)
OpenForWrite	machine/sysdep.h	/^extern int OpenForWrite(char *name);$/;"	p	signature:(char *name)
OpenSocket	machine/sysdep.cc	/^OpenSocket()$/;"	f	signature:()
OpenSocket	machine/sysdep.h	/^extern int OpenSocket();$/;"	p	signature:()
OverflowException	machine/machine.h	/^		     OverflowException,     \/\/ Integer overflow in add or sub.$/;"	e	enum:ExceptionType
P	threads/synch.cc	/^Semaphore::P()$/;"	f	class:Semaphore	signature:()
P	threads/synch.h	/^    void P();	 \/\/ these are the only operations on a semaphore$/;"	p	class:Semaphore	access:public	signature:()
PC	threads/switch.h	113;"	d
PC	threads/switch.h	38;"	d
PC	threads/switch.h	78;"	d
PCReg	machine/machine.h	65;"	d
PCState	threads/switch.h	121;"	d
PCState	threads/switch.h	142;"	d
PCState	threads/switch.h	55;"	d
PCState	threads/switch.h	86;"	d
POST_H	network/post.h	29;"	d
PRIV_LEV	threads/switch.s	/^	.EXPORT SWITCH,ENTRY,PRIV_LEV=3,RTNVAL=GR$/;"	v
PRIV_LEV	threads/switch.s	/^	.EXPORT ThreadRoot,ENTRY,PRIV_LEV=3,RTNVAL=GR$/;"	v
PacketHeader	machine/network.h	/^class PacketHeader {$/;"	c
PacketHeader::from	machine/network.h	/^    NetworkAddress from;	\/\/ source machine ID$/;"	m	class:PacketHeader	access:public
PacketHeader::length	machine/network.h	/^    unsigned length;	 	\/\/ bytes of packet data, excluding the $/;"	m	class:PacketHeader	access:public
PacketHeader::to	machine/network.h	/^    NetworkAddress to;		\/\/ Destination machine ID$/;"	m	class:PacketHeader	access:public
PacketSent	network/post.cc	/^PostOffice::PacketSent()$/;"	f	class:PostOffice	signature:()
PacketSent	network/post.h	/^    void PacketSent();		\/\/ Interrupt handler, called when outgoing $/;"	p	class:PostOffice	access:public	signature:()
PageFaultException	machine/machine.h	/^		     PageFaultException,    \/\/ No valid translation found$/;"	e	enum:ExceptionType
PageSize	machine/machine.h	31;"	d
PendingInterrupt	machine/interrupt.cc	/^PendingInterrupt::PendingInterrupt(VoidFunctionPtr func, int param, int time, $/;"	f	class:PendingInterrupt	signature:(VoidFunctionPtr func, int param, int time, IntType kind)
PendingInterrupt	machine/interrupt.h	/^    PendingInterrupt(VoidFunctionPtr func, int param, int time, IntType kind);$/;"	p	class:PendingInterrupt	access:public	signature:(VoidFunctionPtr func, int param, int time, IntType kind)
PendingInterrupt	machine/interrupt.h	/^class PendingInterrupt {$/;"	c
PendingInterrupt::PendingInterrupt	machine/interrupt.cc	/^PendingInterrupt::PendingInterrupt(VoidFunctionPtr func, int param, int time, $/;"	f	class:PendingInterrupt	signature:(VoidFunctionPtr func, int param, int time, IntType kind)
PendingInterrupt::PendingInterrupt	machine/interrupt.h	/^    PendingInterrupt(VoidFunctionPtr func, int param, int time, IntType kind);$/;"	p	class:PendingInterrupt	access:public	signature:(VoidFunctionPtr func, int param, int time, IntType kind)
PendingInterrupt::arg	machine/interrupt.h	/^    int arg;                    \/\/ The argument to the function.$/;"	m	class:PendingInterrupt	access:public
PendingInterrupt::handler	machine/interrupt.h	/^    VoidFunctionPtr handler;    \/\/ The function (in the hardware device$/;"	m	class:PendingInterrupt	access:public
PendingInterrupt::type	machine/interrupt.h	/^    IntType type;		\/\/ for debugging$/;"	m	class:PendingInterrupt	access:public
PendingInterrupt::when	machine/interrupt.h	/^    int when;			\/\/ When the interrupt is supposed to fire$/;"	m	class:PendingInterrupt	access:public
PerformanceTest	filesys/fstest.cc	/^PerformanceTest()$/;"	f	signature:()
PerformanceTest	threads/main.cc	/^extern void Print(char *file), PerformanceTest(void);$/;"	p	file:	signature:(void)
PollFile	machine/sysdep.cc	/^PollFile(int fd)$/;"	f	signature:(int fd)
PollFile	machine/sysdep.h	/^extern bool PollFile(int fd);$/;"	p	signature:(int fd)
PollSocket	machine/sysdep.cc	/^PollSocket(int sockID)$/;"	f	signature:(int sockID)
PollSocket	machine/sysdep.h	/^extern bool PollSocket(int sockID);$/;"	p	signature:(int sockID)
PostOffice	network/post.cc	/^PostOffice::PostOffice(NetworkAddress addr, double reliability, int nBoxes)$/;"	f	class:PostOffice	signature:(NetworkAddress addr, double reliability, int nBoxes)
PostOffice	network/post.h	/^    PostOffice(NetworkAddress addr, double reliability, int nBoxes);$/;"	p	class:PostOffice	access:public	signature:(NetworkAddress addr, double reliability, int nBoxes)
PostOffice	network/post.h	/^class PostOffice {$/;"	c
PostOffice::IncomingPacket	network/post.cc	/^PostOffice::IncomingPacket()$/;"	f	class:PostOffice	signature:()
PostOffice::IncomingPacket	network/post.h	/^    void IncomingPacket();	\/\/ Interrupt handler, called when incoming$/;"	p	class:PostOffice	access:public	signature:()
PostOffice::PacketSent	network/post.cc	/^PostOffice::PacketSent()$/;"	f	class:PostOffice	signature:()
PostOffice::PacketSent	network/post.h	/^    void PacketSent();		\/\/ Interrupt handler, called when outgoing $/;"	p	class:PostOffice	access:public	signature:()
PostOffice::PostOffice	network/post.cc	/^PostOffice::PostOffice(NetworkAddress addr, double reliability, int nBoxes)$/;"	f	class:PostOffice	signature:(NetworkAddress addr, double reliability, int nBoxes)
PostOffice::PostOffice	network/post.h	/^    PostOffice(NetworkAddress addr, double reliability, int nBoxes);$/;"	p	class:PostOffice	access:public	signature:(NetworkAddress addr, double reliability, int nBoxes)
PostOffice::PostalDelivery	network/post.cc	/^PostOffice::PostalDelivery()$/;"	f	class:PostOffice	signature:()
PostOffice::PostalDelivery	network/post.h	/^    void PostalDelivery();	\/\/ Wait for incoming messages, $/;"	p	class:PostOffice	access:public	signature:()
PostOffice::Receive	network/post.cc	/^PostOffice::Receive(int box, PacketHeader *pktHdr, $/;"	f	class:PostOffice	signature:(int box, PacketHeader *pktHdr, MailHeader *mailHdr, char* data)
PostOffice::Receive	network/post.h	/^    void Receive(int box, PacketHeader *pktHdr, $/;"	p	class:PostOffice	access:public	signature:(int box, PacketHeader *pktHdr, MailHeader *mailHdr, char *data)
PostOffice::Send	network/post.cc	/^PostOffice::Send(PacketHeader pktHdr, MailHeader mailHdr, char* data)$/;"	f	class:PostOffice	signature:(PacketHeader pktHdr, MailHeader mailHdr, char* data)
PostOffice::Send	network/post.h	/^    void Send(PacketHeader pktHdr, MailHeader mailHdr, char *data);$/;"	p	class:PostOffice	access:public	signature:(PacketHeader pktHdr, MailHeader mailHdr, char *data)
PostOffice::boxes	network/post.h	/^    MailBox *boxes;		\/\/ Table of mail boxes to hold incoming mail$/;"	m	class:PostOffice	access:private
PostOffice::messageAvailable	network/post.h	/^    Semaphore *messageAvailable;\/\/ V'ed when message has arrived from network$/;"	m	class:PostOffice	access:private
PostOffice::messageSent	network/post.h	/^    Semaphore *messageSent;	\/\/ V'ed when next message can be sent to network$/;"	m	class:PostOffice	access:private
PostOffice::netAddr	network/post.h	/^    NetworkAddress netAddr;	\/\/ Network address of this machine$/;"	m	class:PostOffice	access:private
PostOffice::network	network/post.h	/^    Network *network;		\/\/ Physical network connection$/;"	m	class:PostOffice	access:private
PostOffice::numBoxes	network/post.h	/^    int numBoxes;		\/\/ Number of mail boxes$/;"	m	class:PostOffice	access:private
PostOffice::sendLock	network/post.h	/^    Lock *sendLock;		\/\/ Only one outgoing message at a time$/;"	m	class:PostOffice	access:private
PostOffice::~PostOffice	network/post.cc	/^PostOffice::~PostOffice()$/;"	f	class:PostOffice	signature:()
PostOffice::~PostOffice	network/post.h	/^    ~PostOffice();		\/\/ De-allocate Post Office data$/;"	p	class:PostOffice	access:public	signature:()
PostalDelivery	network/post.cc	/^PostOffice::PostalDelivery()$/;"	f	class:PostOffice	signature:()
PostalDelivery	network/post.h	/^    void PostalDelivery();	\/\/ Wait for incoming messages, $/;"	p	class:PostOffice	access:public	signature:()
PostalHelper	network/post.cc	/^static void PostalHelper(int arg)$/;"	f	file:	signature:(int arg)
Prepend	threads/list.cc	/^List::Prepend(void *item)$/;"	f	class:List	signature:(void *item)
Prepend	threads/list.h	/^    void Prepend(void *item); 	\/\/ Put item at the beginning of the list$/;"	p	class:List	access:public	signature:(void *item)
PrevPCReg	machine/machine.h	67;"	d
Print	filesys/directory.cc	/^Directory::Print()$/;"	f	class:Directory	signature:()
Print	filesys/directory.h	/^    void Print();			\/\/ Verbose print of the contents$/;"	p	class:Directory	access:public	signature:()
Print	filesys/filehdr.cc	/^FileHeader::Print()$/;"	f	class:FileHeader	signature:()
Print	filesys/filehdr.h	/^    void Print();			\/\/ Print the contents of the file.$/;"	p	class:FileHeader	access:public	signature:()
Print	filesys/filesys.cc	/^FileSystem::Print()$/;"	f	class:FileSystem	signature:()
Print	filesys/filesys.h	/^    void Print();			\/\/ List all the files and their contents$/;"	p	class:FileSystem	access:public	signature:()
Print	filesys/fstest.cc	/^Print(char *name)$/;"	f	signature:(char *name)
Print	machine/stats.cc	/^Statistics::Print()$/;"	f	class:Statistics	signature:()
Print	machine/stats.h	/^    void Print();		\/\/ print collected statistics$/;"	p	class:Statistics	access:public	signature:()
Print	threads/main.cc	/^extern void Print(char *file), PerformanceTest(void);$/;"	p	file:	signature:(char *file)
Print	threads/scheduler.cc	/^NachOSscheduler::Print()$/;"	f	class:NachOSscheduler	signature:()
Print	threads/scheduler.h	/^    void Print();			\/\/ Print contents of ready list$/;"	p	class:NachOSscheduler	access:public	signature:()
Print	threads/thread.h	/^    void Print() { printf("%s, ", name); }$/;"	f	class:NachOSThread	access:public	signature:()
Print	userprog/bitmap.cc	/^BitMap::Print() $/;"	f	class:BitMap	signature:()
Print	userprog/bitmap.h	/^    void Print();		\/\/ Print contents of bitmap$/;"	p	class:BitMap	access:public	signature:()
PrintHeader	network/post.cc	/^PrintHeader(PacketHeader pktHdr, MailHeader mailHdr)$/;"	f	file:	signature:(PacketHeader pktHdr, MailHeader mailHdr)
PrintPending	machine/interrupt.cc	/^PrintPending(int arg)$/;"	f	file:	signature:(int arg)
PrintSector	machine/disk.cc	/^PrintSector (bool writing, int sector, char *data)$/;"	f	file:	signature:(bool writing, int sector, char *data)
ProcessAddrSpace	userprog/addrspace.cc	/^ProcessAddrSpace::ProcessAddrSpace(OpenFile *executable)$/;"	f	class:ProcessAddrSpace	signature:(OpenFile *executable)
ProcessAddrSpace	userprog/addrspace.h	/^    ProcessAddrSpace(OpenFile *executable);	\/\/ Create an address space,$/;"	p	class:ProcessAddrSpace	access:public	signature:(OpenFile *executable)
ProcessAddrSpace	userprog/addrspace.h	/^class ProcessAddrSpace {$/;"	c
ProcessAddrSpace::InitUserCPURegisters	userprog/addrspace.cc	/^ProcessAddrSpace::InitUserCPURegisters()$/;"	f	class:ProcessAddrSpace	signature:()
ProcessAddrSpace::InitUserCPURegisters	userprog/addrspace.h	/^    void InitUserCPURegisters();		\/\/ Initialize user-level CPU registers,$/;"	p	class:ProcessAddrSpace	access:public	signature:()
ProcessAddrSpace::NachOSpageTable	userprog/addrspace.h	/^    TranslationEntry *NachOSpageTable;	\/\/ Assume linear page table translation$/;"	m	class:ProcessAddrSpace	access:private
ProcessAddrSpace::ProcessAddrSpace	userprog/addrspace.cc	/^ProcessAddrSpace::ProcessAddrSpace(OpenFile *executable)$/;"	f	class:ProcessAddrSpace	signature:(OpenFile *executable)
ProcessAddrSpace::ProcessAddrSpace	userprog/addrspace.h	/^    ProcessAddrSpace(OpenFile *executable);	\/\/ Create an address space,$/;"	p	class:ProcessAddrSpace	access:public	signature:(OpenFile *executable)
ProcessAddrSpace::RestoreStateOnSwitch	userprog/addrspace.cc	/^void ProcessAddrSpace::RestoreStateOnSwitch() $/;"	f	class:ProcessAddrSpace	signature:()
ProcessAddrSpace::RestoreStateOnSwitch	userprog/addrspace.h	/^    void RestoreStateOnSwitch();		\/\/ info on a context switch $/;"	p	class:ProcessAddrSpace	access:public	signature:()
ProcessAddrSpace::SaveStateOnSwitch	userprog/addrspace.cc	/^void ProcessAddrSpace::SaveStateOnSwitch() $/;"	f	class:ProcessAddrSpace	signature:()
ProcessAddrSpace::SaveStateOnSwitch	userprog/addrspace.h	/^    void SaveStateOnSwitch();			\/\/ Save\/restore address space-specific$/;"	p	class:ProcessAddrSpace	access:public	signature:()
ProcessAddrSpace::numPagesInVM	userprog/addrspace.h	/^    unsigned int numPagesInVM;		\/\/ Number of pages in the virtual $/;"	m	class:ProcessAddrSpace	access:private
ProcessAddrSpace::~ProcessAddrSpace	userprog/addrspace.cc	/^ProcessAddrSpace::~ProcessAddrSpace()$/;"	f	class:ProcessAddrSpace	signature:()
ProcessAddrSpace::~ProcessAddrSpace	userprog/addrspace.h	/^    ~ProcessAddrSpace();			\/\/ De-allocate an address space$/;"	p	class:ProcessAddrSpace	access:public	signature:()
Put	network/post.cc	/^MailBox::Put(PacketHeader pktHdr, MailHeader mailHdr, char *data)$/;"	f	class:MailBox	signature:(PacketHeader pktHdr, MailHeader mailHdr, char *data)
Put	network/post.h	/^    void Put(PacketHeader pktHdr, MailHeader mailHdr, char *data);$/;"	p	class:MailBox	access:public	signature:(PacketHeader pktHdr, MailHeader mailHdr, char *data)
PutChar	machine/console.cc	/^Console::PutChar(char ch)$/;"	f	class:Console	signature:(char ch)
PutChar	machine/console.h	/^    void PutChar(char ch);	\/\/ Write "ch" to the console display, $/;"	p	class:Console	access:public	signature:(char ch)
PutThreadToSleep	threads/thread.cc	/^NachOSThread::PutThreadToSleep ()$/;"	f	class:NachOSThread	signature:()
PutThreadToSleep	threads/thread.h	/^    void PutThreadToSleep();  				\/\/ Put the thread to sleep and $/;"	p	class:NachOSThread	access:public	signature:()
R	bin/d.c	27;"	d	file:
R31	machine/mipssim.h	97;"	d
RAND	bin/disasm.c	/^int NROWS=64, ASSOC=1, LINESIZE=4, RAND=0, LRD=0;$/;"	v
RAND	bin/main.c	/^int NROWS=64, ASSOC=1, LINESIZE=4, RAND=0, LRD=0;$/;"	v
RD	machine/mipssim.h	/^enum RegType { NONE, RS, RT, RD, EXTRA }; $/;"	e	enum:RegType
READY	threads/thread.h	/^enum ThreadStatus { JUST_CREATED, RUNNING, READY, BLOCKED };$/;"	e	enum:ThreadStatus
RFMT	machine/mipssim.h	110;"	d
RS	machine/mipssim.h	/^enum RegType { NONE, RS, RT, RD, EXTRA }; $/;"	e	enum:RegType
RT	machine/mipssim.h	/^enum RegType { NONE, RS, RT, RD, EXTRA }; $/;"	e	enum:RegType
RTNVAL	threads/switch.s	/^	.EXPORT SWITCH,ENTRY,PRIV_LEV=3,RTNVAL=GR$/;"	v
RTNVAL	threads/switch.s	/^	.EXPORT ThreadRoot,ENTRY,PRIV_LEV=3,RTNVAL=GR$/;"	v
RUNNING	threads/thread.h	/^enum ThreadStatus { JUST_CREATED, RUNNING, READY, BLOCKED };$/;"	e	enum:ThreadStatus
RaiseException	machine/machine.cc	/^Machine::RaiseException(ExceptionType which, int badVAddr)$/;"	f	class:Machine	signature:(ExceptionType which, int badVAddr)
RaiseException	machine/machine.h	/^    void RaiseException(ExceptionType which, int badVAddr);$/;"	p	class:Machine	access:public	signature:(ExceptionType which, int badVAddr)
Random	machine/sysdep.cc	/^Random()$/;"	f	signature:()
Random	machine/sysdep.h	/^extern int Random();$/;"	p	signature:()
RandomInit	machine/sysdep.cc	/^RandomInit(unsigned seed)$/;"	f	signature:(unsigned seed)
RandomInit	machine/sysdep.h	/^extern void RandomInit(unsigned seed);$/;"	p	signature:(unsigned seed)
Read	bin/coff2flat.c	/^void Read(int fd, char *buf, int nBytes)$/;"	f	signature:(int fd, char *buf, int nBytes)
Read	bin/coff2noff.c	/^void Read(int fd, char *buf, int nBytes)$/;"	f	signature:(int fd, char *buf, int nBytes)
Read	filesys/openfile.cc	/^OpenFile::Read(char *into, int numBytes)$/;"	f	class:OpenFile	signature:(char *into, int numBytes)
Read	filesys/openfile.h	/^    int Read(char *into, int numBytes) {$/;"	f	class:OpenFile	access:public	signature:(char *into, int numBytes)
Read	filesys/openfile.h	/^    int Read(char *into, int numBytes); \/\/ Read\/write bytes from the file,$/;"	p	class:OpenFile	access:public	signature:(char *into, int numBytes)
Read	machine/sysdep.cc	/^Read(int fd, char *buffer, int nBytes)$/;"	f	signature:(int fd, char *buffer, int nBytes)
Read	machine/sysdep.h	/^extern void Read(int fd, char *buffer, int nBytes);$/;"	p	signature:(int fd, char *buffer, int nBytes)
ReadAt	filesys/openfile.cc	/^OpenFile::ReadAt(char *into, int numBytes, int position)$/;"	f	class:OpenFile	signature:(char *into, int numBytes, int position)
ReadAt	filesys/openfile.h	/^    int ReadAt(char *into, int numBytes, int position) { $/;"	f	class:OpenFile	access:public	signature:(char *into, int numBytes, int position)
ReadAt	filesys/openfile.h	/^    int ReadAt(char *into, int numBytes, int position);$/;"	p	class:OpenFile	access:public	signature:(char *into, int numBytes, int position)
ReadAvail	network/post.cc	/^static void ReadAvail(int arg)$/;"	f	file:	signature:(int arg)
ReadAvail	userprog/exception.cc	/^static void ReadAvail(int arg) { readAvail->V(); }$/;"	f	file:	signature:(int arg)
ReadAvail	userprog/progtest.cc	/^static void ReadAvail(int arg) { readAvail->V(); }$/;"	f	file:	signature:(int arg)
ReadFromSocket	machine/sysdep.cc	/^ReadFromSocket(int sockID, char *buffer, int packetSize)$/;"	f	signature:(int sockID, char *buffer, int packetSize)
ReadFromSocket	machine/sysdep.h	/^extern void ReadFromSocket(int sockID, char *buffer, int packetSize);$/;"	p	signature:(int sockID, char *buffer, int packetSize)
ReadMem	machine/machine.h	/^    bool ReadMem(int addr, int size, int* value);$/;"	p	class:Machine	access:public	signature:(int addr, int size, int* value)
ReadMem	machine/translate.cc	/^Machine::ReadMem(int addr, int size, int *value)$/;"	f	class:Machine	signature:(int addr, int size, int *value)
ReadOnlyException	machine/machine.h	/^		     ReadOnlyException,     \/\/ Write attempted to page marked $/;"	e	enum:ExceptionType
ReadPartial	machine/sysdep.cc	/^ReadPartial(int fd, char *buffer, int nBytes)$/;"	f	signature:(int fd, char *buffer, int nBytes)
ReadPartial	machine/sysdep.h	/^extern int ReadPartial(int fd, char *buffer, int nBytes);$/;"	p	signature:(int fd, char *buffer, int nBytes)
ReadRegister	machine/machine.cc	/^int Machine::ReadRegister(int num)$/;"	f	class:Machine	signature:(int num)
ReadRegister	machine/machine.h	/^    int ReadRegister(int num);	\/\/ read the contents of a CPU register$/;"	p	class:Machine	access:public	signature:(int num)
ReadRequest	machine/disk.cc	/^Disk::ReadRequest(int sectorNumber, char* data)$/;"	f	class:Disk	signature:(int sectorNumber, char* data)
ReadRequest	machine/disk.h	/^    void ReadRequest(int sectorNumber, char* data);$/;"	p	class:Disk	access:public	signature:(int sectorNumber, char* data)
ReadSector	filesys/synchdisk.cc	/^SynchDisk::ReadSector(int sectorNumber, char* data)$/;"	f	class:SynchDisk	signature:(int sectorNumber, char* data)
ReadSector	filesys/synchdisk.h	/^    void ReadSector(int sectorNumber, char* data);$/;"	p	class:SynchDisk	access:public	signature:(int sectorNumber, char* data)
ReadStruct	bin/coff2flat.c	32;"	d	file:
ReadStruct	bin/coff2noff.c	68;"	d	file:
Receive	machine/network.cc	/^Network::Receive(char* data)$/;"	f	class:Network	signature:(char* data)
Receive	machine/network.h	/^    PacketHeader Receive(char* data);$/;"	p	class:Network	access:public	signature:(char* data)
Receive	network/post.cc	/^PostOffice::Receive(int box, PacketHeader *pktHdr, $/;"	f	class:PostOffice	signature:(int box, PacketHeader *pktHdr, MailHeader *mailHdr, char* data)
Receive	network/post.h	/^    void Receive(int box, PacketHeader *pktHdr, $/;"	p	class:PostOffice	access:public	signature:(int box, PacketHeader *pktHdr, MailHeader *mailHdr, char *data)
Reg	bin/execute.c	/^int Reg[32];			\/* GPR's *\/$/;"	v
RegType	machine/mipssim.h	/^enum RegType { NONE, RS, RT, RD, EXTRA }; $/;"	g
Regtrace	bin/disasm.c	/^int TRACE, Traptrace, Regtrace;$/;"	v
Regtrace	bin/main.c	/^int TRACE, Traptrace, Regtrace;$/;"	v
Release	threads/synch.cc	/^void Lock::Release() {}$/;"	f	class:Lock	signature:()
Release	threads/synch.h	/^    void Release(); \/\/ they are both *atomic*$/;"	p	class:Lock	access:public	signature:()
Remove	filesys/directory.cc	/^Directory::Remove(char *name)$/;"	f	class:Directory	signature:(char *name)
Remove	filesys/directory.h	/^    bool Remove(char *name);		\/\/ Remove a file from the directory$/;"	p	class:Directory	access:public	signature:(char *name)
Remove	filesys/filesys.cc	/^FileSystem::Remove(char *name)$/;"	f	class:FileSystem	signature:(char *name)
Remove	filesys/filesys.h	/^    bool Remove(char *name) { return Unlink(name) == 0; }$/;"	f	class:FileSystem	access:public	signature:(char *name)
Remove	filesys/filesys.h	/^    bool Remove(char *name);  		\/\/ Delete a file (UNIX unlink)$/;"	p	class:FileSystem	access:public	signature:(char *name)
Remove	threads/list.cc	/^List::Remove()$/;"	f	class:List	signature:()
Remove	threads/list.h	/^    void *Remove(); 	 	\/\/ Take item off the front of the list$/;"	p	class:List	access:public	signature:()
Remove	threads/synchlist.cc	/^SynchList::Remove()$/;"	f	class:SynchList	signature:()
Remove	threads/synchlist.h	/^    void *Remove();		\/\/ remove the first item from the front of$/;"	p	class:SynchList	access:public	signature:()
RemoveFromSleep	threads/scheduler.cc	/^NachOSscheduler::RemoveFromSleep (int *keyPtr){$/;"	f	class:NachOSscheduler	signature:(int *keyPtr)
RemoveFromSleep	threads/scheduler.h	/^    void *RemoveFromSleep(int *keyPtr);$/;"	p	class:NachOSscheduler	access:public	signature:(int *keyPtr)
RequestDone	filesys/synchdisk.cc	/^SynchDisk::RequestDone()$/;"	f	class:SynchDisk	signature:()
RequestDone	filesys/synchdisk.h	/^    void RequestDone();			\/\/ Called by the disk device interrupt$/;"	p	class:SynchDisk	access:public	signature:()
RestoreStateOnSwitch	userprog/addrspace.cc	/^void ProcessAddrSpace::RestoreStateOnSwitch() $/;"	f	class:ProcessAddrSpace	signature:()
RestoreStateOnSwitch	userprog/addrspace.h	/^    void RestoreStateOnSwitch();		\/\/ info on a context switch $/;"	p	class:ProcessAddrSpace	access:public	signature:()
RestoreUserState	threads/thread.cc	/^NachOSThread::RestoreUserState()$/;"	f	class:NachOSThread	signature:()
RestoreUserState	threads/thread.h	/^    void RestoreUserState();		\/\/ restore user-level register state$/;"	p	class:NachOSThread	access:public	signature:()
RetAddrReg	machine/machine.h	61;"	d
RotationTime	machine/stats.h	54;"	d
Run	machine/machine.h	/^    void Run();	 		\/\/ Run a user program$/;"	p	class:Machine	access:public	signature:()
Run	machine/mipssim.cc	/^Machine::Run()$/;"	f	class:Machine	signature:()
S0	threads/switch.h	29;"	d
S0	threads/switch.h	97;"	d
S1	threads/switch.h	30;"	d
S1	threads/switch.h	98;"	d
S10	threads/switch.h	107;"	d
S11	threads/switch.h	108;"	d
S12	threads/switch.h	109;"	d
S13	threads/switch.h	110;"	d
S14	threads/switch.h	111;"	d
S15	threads/switch.h	112;"	d
S2	threads/switch.h	31;"	d
S2	threads/switch.h	99;"	d
S3	threads/switch.h	100;"	d
S3	threads/switch.h	32;"	d
S4	threads/switch.h	101;"	d
S4	threads/switch.h	33;"	d
S5	threads/switch.h	102;"	d
S5	threads/switch.h	34;"	d
S6	threads/switch.h	103;"	d
S6	threads/switch.h	35;"	d
S7	threads/switch.h	104;"	d
S7	threads/switch.h	36;"	d
S8	threads/switch.h	105;"	d
S9	threads/switch.h	106;"	d
SCHEDULER_H	threads/scheduler.h	10;"	d
SIGN_BIT	machine/mipssim.h	96;"	d
SIZE	test/testregPA.c	2;"	d	file:
SIZE	test/vectorsum.c	2;"	d	file:
SOMAGIC	bin/coff.h	18;"	d
SP	threads/switch.h	28;"	d
SP	threads/switch.h	96;"	d
SPECIAL	machine/mipssim.h	105;"	d
STACK_FENCEPOST	threads/thread.cc	23;"	d	file:
STATS_H	machine/stats.h	12;"	d
SWITCH_H	threads/switch.h	18;"	d
SYNCHDISK_H	filesys/synchdisk.h	12;"	d
SYNCHLIST_H	threads/synchlist.h	12;"	d
SYNCH_H	threads/synch.h	18;"	d
SYSCALLS_H	userprog/syscall.h	14;"	d
SYSDEP_H	machine/sysdep.h	12;"	d
SYSTEM_H	threads/system.h	9;"	d
SYScall_Close	userprog/syscall.h	29;"	d
SYScall_Create	userprog/syscall.h	25;"	d
SYScall_Exec	userprog/syscall.h	23;"	d
SYScall_Exit	userprog/syscall.h	22;"	d
SYScall_Fork	userprog/syscall.h	30;"	d
SYScall_GetPA	userprog/syscall.h	40;"	d
SYScall_GetPID	userprog/syscall.h	41;"	d
SYScall_GetPPID	userprog/syscall.h	42;"	d
SYScall_GetReg	userprog/syscall.h	39;"	d
SYScall_Halt	userprog/syscall.h	21;"	d
SYScall_Join	userprog/syscall.h	24;"	d
SYScall_NumInstr	userprog/syscall.h	50;"	d
SYScall_Open	userprog/syscall.h	26;"	d
SYScall_PrintChar	userprog/syscall.h	36;"	d
SYScall_PrintInt	userprog/syscall.h	35;"	d
SYScall_PrintIntHex	userprog/syscall.h	48;"	d
SYScall_PrintString	userprog/syscall.h	37;"	d
SYScall_Read	userprog/syscall.h	27;"	d
SYScall_Sleep	userprog/syscall.h	44;"	d
SYScall_Time	userprog/syscall.h	46;"	d
SYScall_Write	userprog/syscall.h	28;"	d
SYScall_Yield	userprog/syscall.h	31;"	d
SaveStateOnSwitch	userprog/addrspace.cc	/^void ProcessAddrSpace::SaveStateOnSwitch() $/;"	f	class:ProcessAddrSpace	signature:()
SaveStateOnSwitch	userprog/addrspace.h	/^    void SaveStateOnSwitch();			\/\/ Save\/restore address space-specific$/;"	p	class:ProcessAddrSpace	access:public	signature:()
SaveUserState	threads/thread.cc	/^NachOSThread::SaveUserState()$/;"	f	class:NachOSThread	signature:()
SaveUserState	threads/thread.h	/^    void SaveUserState();		\/\/ save user-level register state$/;"	p	class:NachOSThread	access:public	signature:()
Schedule	machine/interrupt.cc	/^Interrupt::Schedule(VoidFunctionPtr handler, int arg, int fromNow, IntType type)$/;"	f	class:Interrupt	signature:(VoidFunctionPtr handler, int arg, int fromNow, IntType type)
Schedule	machine/interrupt.h	/^    void Schedule(VoidFunctionPtr handler,\/\/ Schedule an interrupt to occur$/;"	p	class:Interrupt	access:public	signature:(VoidFunctionPtr handler, int arg, int when, IntType type)
Schedule	threads/scheduler.cc	/^NachOSscheduler::Schedule (NachOSThread *nextThread)$/;"	f	class:NachOSscheduler	signature:(NachOSThread *nextThread)
Schedule	threads/scheduler.h	/^    void Schedule(NachOSThread* nextThread);	\/\/ Cause nextThread to start running$/;"	p	class:NachOSscheduler	access:public	signature:(NachOSThread* nextThread)
SectorSize	machine/disk.h	49;"	d
SectorsPerTrack	machine/disk.h	50;"	d
Seek	filesys/openfile.cc	/^OpenFile::Seek(int position)$/;"	f	class:OpenFile	signature:(int position)
Seek	filesys/openfile.h	/^    void Seek(int position); 		\/\/ Set the position from which to $/;"	p	class:OpenFile	access:public	signature:(int position)
SeekTime	machine/stats.h	55;"	d
Segment	bin/noff.h	/^} Segment;$/;"	t	typeref:struct:segment
Semaphore	threads/synch.cc	/^Semaphore::Semaphore(char* debugName, int initialValue)$/;"	f	class:Semaphore	signature:(char* debugName, int initialValue)
Semaphore	threads/synch.h	/^    Semaphore(char* debugName, int initialValue);	\/\/ set initial value$/;"	p	class:Semaphore	access:public	signature:(char* debugName, int initialValue)
Semaphore	threads/synch.h	/^class Semaphore {$/;"	c
Semaphore::P	threads/synch.cc	/^Semaphore::P()$/;"	f	class:Semaphore	signature:()
Semaphore::P	threads/synch.h	/^    void P();	 \/\/ these are the only operations on a semaphore$/;"	p	class:Semaphore	access:public	signature:()
Semaphore::Semaphore	threads/synch.cc	/^Semaphore::Semaphore(char* debugName, int initialValue)$/;"	f	class:Semaphore	signature:(char* debugName, int initialValue)
Semaphore::Semaphore	threads/synch.h	/^    Semaphore(char* debugName, int initialValue);	\/\/ set initial value$/;"	p	class:Semaphore	access:public	signature:(char* debugName, int initialValue)
Semaphore::V	threads/synch.cc	/^Semaphore::V()$/;"	f	class:Semaphore	signature:()
Semaphore::V	threads/synch.h	/^    void V();	 \/\/ they are both *atomic*$/;"	p	class:Semaphore	access:public	signature:()
Semaphore::getName	threads/synch.h	/^    char* getName() { return name;}			\/\/ debugging assist$/;"	f	class:Semaphore	access:public	signature:()
Semaphore::name	threads/synch.h	/^    char* name;        \/\/ useful for debugging$/;"	m	class:Semaphore	access:private
Semaphore::queue	threads/synch.h	/^    List *queue;       \/\/ threads waiting in P() for the value to be > 0$/;"	m	class:Semaphore	access:private
Semaphore::value	threads/synch.h	/^    int value;         \/\/ semaphore value, always >= 0$/;"	m	class:Semaphore	access:private
Semaphore::~Semaphore	threads/synch.cc	/^Semaphore::~Semaphore()$/;"	f	class:Semaphore	signature:()
Semaphore::~Semaphore	threads/synch.h	/^    ~Semaphore();   					\/\/ de-allocate semaphore$/;"	p	class:Semaphore	access:public	signature:()
Send	machine/network.cc	/^Network::Send(PacketHeader hdr, char* data)$/;"	f	class:Network	signature:(PacketHeader hdr, char* data)
Send	machine/network.h	/^    void Send(PacketHeader hdr, char* data);$/;"	p	class:Network	access:public	signature:(PacketHeader hdr, char* data)
Send	network/post.cc	/^PostOffice::Send(PacketHeader pktHdr, MailHeader mailHdr, char* data)$/;"	f	class:PostOffice	signature:(PacketHeader pktHdr, MailHeader mailHdr, char* data)
Send	network/post.h	/^    void Send(PacketHeader pktHdr, MailHeader mailHdr, char *data);$/;"	p	class:PostOffice	access:public	signature:(PacketHeader pktHdr, MailHeader mailHdr, char *data)
SendDone	machine/network.cc	/^Network::SendDone()$/;"	f	class:Network	signature:()
SendDone	machine/network.h	/^    void SendDone();		\/\/ Interrupt handler, called when message is $/;"	p	class:Network	access:public	signature:()
SendToSocket	machine/sysdep.cc	/^SendToSocket(int sockID, char *buffer, int packetSize, char *toName)$/;"	f	signature:(int sockID, char *buffer, int packetSize, char *toName)
SendToSocket	machine/sysdep.h	/^extern void SendToSocket(int sockID, char *buffer, int packetSize,char *toName);$/;"	p	signature:(int sockID, char *buffer, int packetSize,char *toName)
SetLevel	machine/interrupt.cc	/^Interrupt::SetLevel(IntStatus now)$/;"	f	class:Interrupt	signature:(IntStatus now)
SetLevel	machine/interrupt.h	/^    IntStatus SetLevel(IntStatus level);\/\/ Disable or enable interrupts $/;"	p	class:Interrupt	access:public	signature:(IntStatus level)
ShortToHost	bin/coff2noff.c	/^ShortToHost(unsigned short shortword) {$/;"	f	signature:(unsigned short shortword)
ShortToHost	machine/machine.h	/^unsigned short ShortToHost(unsigned short shortword);$/;"	p	signature:(unsigned short shortword)
ShortToHost	machine/translate.cc	/^ShortToHost(unsigned short shortword) {$/;"	f	signature:(unsigned short shortword)
ShortToMachine	machine/machine.h	/^unsigned short ShortToMachine(unsigned short shortword);$/;"	p	signature:(unsigned short shortword)
ShortToMachine	machine/translate.cc	/^ShortToMachine(unsigned short shortword) { return ShortToHost(shortword); }$/;"	f	signature:(unsigned short shortword)
Signal	threads/synch.cc	/^void Condition::Signal(Lock* conditionLock) { }$/;"	f	class:Condition	signature:(Lock* conditionLock)
Signal	threads/synch.h	/^    void Signal(Lock *conditionLock);   \/\/ conditionLock must be held by$/;"	p	class:Condition	access:public	signature:(Lock *conditionLock)
SimpleThread	threads/threadtest.cc	/^SimpleThread(int which)$/;"	f	signature:(int which)
SortedInsert	threads/list.cc	/^List::SortedInsert(void *item, int sortKey)$/;"	f	class:List	signature:(void *item, int sortKey)
SortedInsert	threads/list.h	/^    void SortedInsert(void *item, int sortKey);	\/\/ Put item into list$/;"	p	class:List	access:public	signature:(void *item, int sortKey)
SortedRemove	threads/list.cc	/^List::SortedRemove(int *keyPtr)$/;"	f	class:List	signature:(int *keyPtr)
SortedRemove	threads/list.h	/^    void *SortedRemove(int *keyPtr); 	  	\/\/ Remove first item from list$/;"	p	class:List	access:public	signature:(int *keyPtr)
SpaceId	userprog/syscall.h	/^typedef int SpaceId;	$/;"	t
StackReg	machine/machine.h	60;"	d
StackSize	bin/coff2flat.c	31;"	d	file:
StackSize	threads/thread.h	56;"	d
StartUserProcess	threads/main.cc	/^extern void StartUserProcess(char *file), ConsoleTest(char *in, char *out);$/;"	p	file:	signature:(char *file)
StartUserProcess	userprog/exception.cc	/^extern void StartUserProcess(char *filename);$/;"	p	file:	signature:(char *filename)
StartUserProcess	userprog/progtest.cc	/^StartUserProcess(char *filename)$/;"	f	signature:(char *filename)
StartupPC	threads/switch.h	119;"	d
StartupPC	threads/switch.h	152;"	d
StartupPC	threads/switch.h	53;"	d
StartupPC	threads/switch.h	84;"	d
StartupPCState	threads/switch.h	125;"	d
StartupPCState	threads/switch.h	147;"	d
StartupPCState	threads/switch.h	60;"	d
StartupPCState	threads/switch.h	90;"	d
Statistics	machine/stats.cc	/^Statistics::Statistics()$/;"	f	class:Statistics	signature:()
Statistics	machine/stats.h	/^    Statistics(); 		\/\/ initialize everything to zero$/;"	p	class:Statistics	access:public	signature:()
Statistics	machine/stats.h	/^class Statistics {$/;"	c
Statistics::Print	machine/stats.cc	/^Statistics::Print()$/;"	f	class:Statistics	signature:()
Statistics::Print	machine/stats.h	/^    void Print();		\/\/ print collected statistics$/;"	p	class:Statistics	access:public	signature:()
Statistics::Statistics	machine/stats.cc	/^Statistics::Statistics()$/;"	f	class:Statistics	signature:()
Statistics::Statistics	machine/stats.h	/^    Statistics(); 		\/\/ initialize everything to zero$/;"	p	class:Statistics	access:public	signature:()
Statistics::idleTicks	machine/stats.h	/^    int idleTicks;       	\/\/ Time spent idle (no threads to run)$/;"	m	class:Statistics	access:public
Statistics::numConsoleCharsRead	machine/stats.h	/^    int numConsoleCharsRead;	\/\/ number of characters read from the keyboard$/;"	m	class:Statistics	access:public
Statistics::numConsoleCharsWritten	machine/stats.h	/^    int numConsoleCharsWritten; \/\/ number of characters written to the display$/;"	m	class:Statistics	access:public
Statistics::numDiskReads	machine/stats.h	/^    int numDiskReads;		\/\/ number of disk read requests$/;"	m	class:Statistics	access:public
Statistics::numDiskWrites	machine/stats.h	/^    int numDiskWrites;		\/\/ number of disk write requests$/;"	m	class:Statistics	access:public
Statistics::numPacketsRecvd	machine/stats.h	/^    int numPacketsRecvd;	\/\/ number of packets received over the network$/;"	m	class:Statistics	access:public
Statistics::numPacketsSent	machine/stats.h	/^    int numPacketsSent;		\/\/ number of packets sent over the network$/;"	m	class:Statistics	access:public
Statistics::numPageFaults	machine/stats.h	/^    int numPageFaults;		\/\/ number of virtual memory page faults$/;"	m	class:Statistics	access:public
Statistics::systemTicks	machine/stats.h	/^    int systemTicks;	 	\/\/ Time spent executing system code$/;"	m	class:Statistics	access:public
Statistics::totalTicks	machine/stats.h	/^    int totalTicks;      	\/\/ Total time running Nachos$/;"	m	class:Statistics	access:public
Statistics::userTicks	machine/stats.h	/^    int userTicks;       	\/\/ Time spent executing user code$/;"	m	class:Statistics	access:public
SwapHeader	userprog/addrspace.cc	/^SwapHeader (NoffHeader *noffH)$/;"	f	file:	signature:(NoffHeader *noffH)
SynchDisk	filesys/synchdisk.cc	/^SynchDisk::SynchDisk(char* name)$/;"	f	class:SynchDisk	signature:(char* name)
SynchDisk	filesys/synchdisk.h	/^    SynchDisk(char* name);    		\/\/ Initialize a synchronous disk,$/;"	p	class:SynchDisk	access:public	signature:(char* name)
SynchDisk	filesys/synchdisk.h	/^class SynchDisk {$/;"	c
SynchDisk::ReadSector	filesys/synchdisk.cc	/^SynchDisk::ReadSector(int sectorNumber, char* data)$/;"	f	class:SynchDisk	signature:(int sectorNumber, char* data)
SynchDisk::ReadSector	filesys/synchdisk.h	/^    void ReadSector(int sectorNumber, char* data);$/;"	p	class:SynchDisk	access:public	signature:(int sectorNumber, char* data)
SynchDisk::RequestDone	filesys/synchdisk.cc	/^SynchDisk::RequestDone()$/;"	f	class:SynchDisk	signature:()
SynchDisk::RequestDone	filesys/synchdisk.h	/^    void RequestDone();			\/\/ Called by the disk device interrupt$/;"	p	class:SynchDisk	access:public	signature:()
SynchDisk::SynchDisk	filesys/synchdisk.cc	/^SynchDisk::SynchDisk(char* name)$/;"	f	class:SynchDisk	signature:(char* name)
SynchDisk::SynchDisk	filesys/synchdisk.h	/^    SynchDisk(char* name);    		\/\/ Initialize a synchronous disk,$/;"	p	class:SynchDisk	access:public	signature:(char* name)
SynchDisk::WriteSector	filesys/synchdisk.cc	/^SynchDisk::WriteSector(int sectorNumber, char* data)$/;"	f	class:SynchDisk	signature:(int sectorNumber, char* data)
SynchDisk::WriteSector	filesys/synchdisk.h	/^    void WriteSector(int sectorNumber, char* data);$/;"	p	class:SynchDisk	access:public	signature:(int sectorNumber, char* data)
SynchDisk::disk	filesys/synchdisk.h	/^    Disk *disk;		  		\/\/ Raw disk device$/;"	m	class:SynchDisk	access:private
SynchDisk::lock	filesys/synchdisk.h	/^    Lock *lock;		  		\/\/ Only one read\/write request$/;"	m	class:SynchDisk	access:private
SynchDisk::semaphore	filesys/synchdisk.h	/^    Semaphore *semaphore; 		\/\/ To synchronize requesting thread $/;"	m	class:SynchDisk	access:private
SynchDisk::~SynchDisk	filesys/synchdisk.cc	/^SynchDisk::~SynchDisk()$/;"	f	class:SynchDisk	signature:()
SynchDisk::~SynchDisk	filesys/synchdisk.h	/^    ~SynchDisk();			\/\/ De-allocate the synch disk data$/;"	p	class:SynchDisk	access:public	signature:()
SynchList	threads/synchlist.cc	/^SynchList::SynchList()$/;"	f	class:SynchList	signature:()
SynchList	threads/synchlist.h	/^    SynchList();		\/\/ initialize a synchronized list$/;"	p	class:SynchList	access:public	signature:()
SynchList	threads/synchlist.h	/^class SynchList {$/;"	c
SynchList::Append	threads/synchlist.cc	/^SynchList::Append(void *item)$/;"	f	class:SynchList	signature:(void *item)
SynchList::Append	threads/synchlist.h	/^    void Append(void *item);	\/\/ append item to the end of the list,$/;"	p	class:SynchList	access:public	signature:(void *item)
SynchList::Mapcar	threads/synchlist.cc	/^SynchList::Mapcar(VoidFunctionPtr func)$/;"	f	class:SynchList	signature:(VoidFunctionPtr func)
SynchList::Mapcar	threads/synchlist.h	/^    void Mapcar(VoidFunctionPtr func);$/;"	p	class:SynchList	access:public	signature:(VoidFunctionPtr func)
SynchList::Remove	threads/synchlist.cc	/^SynchList::Remove()$/;"	f	class:SynchList	signature:()
SynchList::Remove	threads/synchlist.h	/^    void *Remove();		\/\/ remove the first item from the front of$/;"	p	class:SynchList	access:public	signature:()
SynchList::SynchList	threads/synchlist.cc	/^SynchList::SynchList()$/;"	f	class:SynchList	signature:()
SynchList::SynchList	threads/synchlist.h	/^    SynchList();		\/\/ initialize a synchronized list$/;"	p	class:SynchList	access:public	signature:()
SynchList::list	threads/synchlist.h	/^    List *list;			\/\/ the unsynchronized list$/;"	m	class:SynchList	access:private
SynchList::listEmpty	threads/synchlist.h	/^    Condition *listEmpty;	\/\/ wait in Remove if the list is empty$/;"	m	class:SynchList	access:private
SynchList::lock	threads/synchlist.h	/^    Lock *lock;			\/\/ enforce mutual exclusive access to the list$/;"	m	class:SynchList	access:private
SynchList::~SynchList	threads/synchlist.cc	/^SynchList::~SynchList()$/;"	f	class:SynchList	signature:()
SynchList::~SynchList	threads/synchlist.h	/^    ~SynchList();		\/\/ de-allocate a synchronized list$/;"	p	class:SynchList	access:public	signature:()
SyscallException	machine/machine.h	/^		     SyscallException,      \/\/ A program executed a system call.$/;"	e	enum:ExceptionType
SystemMode	machine/interrupt.h	/^enum MachineStatus {IdleMode, SystemMode, UserMode};$/;"	e	enum:MachineStatus
SystemTick	machine/stats.h	53;"	d
THREAD_H	threads/thread.h	38;"	d
TIMER_H	machine/timer.h	21;"	d
TLBSize	machine/machine.h	37;"	d
TLB_H	machine/translate.h	19;"	d
TRACE	bin/disasm.c	/^int TRACE, Traptrace, Regtrace;$/;"	v
TRACE	bin/main.c	/^int TRACE, Traptrace, Regtrace;$/;"	v
TRUE	threads/utility.h	33;"	d
Tell	machine/sysdep.cc	/^Tell(int fd)$/;"	f	signature:(int fd)
Tell	machine/sysdep.h	/^extern int Tell(int fd);$/;"	p	signature:(int fd)
Test	userprog/bitmap.cc	/^BitMap::Test(int which)$/;"	f	class:BitMap	signature:(int which)
Test	userprog/bitmap.h	/^    bool Test(int which);   	\/\/ Is the "nth" bit set?$/;"	p	class:BitMap	access:public	signature:(int which)
ThreadFinish	threads/thread.cc	/^static void ThreadFinish()    { currentThread->FinishThread(); }$/;"	f	file:	signature:()
ThreadFork	threads/thread.cc	/^NachOSThread::ThreadFork(VoidFunctionPtr func, int arg)$/;"	f	class:NachOSThread	signature:(VoidFunctionPtr func, int arg)
ThreadFork	threads/thread.h	/^    void ThreadFork(VoidFunctionPtr func, int arg); 	\/\/ Make thread run (*func)(arg)$/;"	p	class:NachOSThread	access:public	signature:(VoidFunctionPtr func, int arg)
ThreadIsReadyToRun	threads/scheduler.cc	/^NachOSscheduler::ThreadIsReadyToRun (NachOSThread *thread)$/;"	f	class:NachOSscheduler	signature:(NachOSThread *thread)
ThreadIsReadyToRun	threads/scheduler.h	/^    void ThreadIsReadyToRun(NachOSThread* thread);	\/\/ Thread can be dispatched.$/;"	p	class:NachOSscheduler	access:public	signature:(NachOSThread* thread)
ThreadIsReadyToSleep	threads/scheduler.cc	/^NachOSscheduler::ThreadIsReadyToSleep (NachOSThread *thread, int ticks)$/;"	f	class:NachOSscheduler	signature:(NachOSThread *thread, int ticks)
ThreadIsReadyToSleep	threads/scheduler.h	/^    void ThreadIsReadyToSleep(NachOSThread* thread, int ticks);$/;"	p	class:NachOSscheduler	access:public	signature:(NachOSThread* thread, int ticks)
ThreadPrint	threads/thread.cc	/^void ThreadPrint(int arg){ NachOSThread *t = (NachOSThread *)arg; t->Print(); }$/;"	f	signature:(int arg)
ThreadPrint	threads/thread.h	/^extern void ThreadPrint(int arg);	 $/;"	p	signature:(int arg)
ThreadStatus	threads/thread.h	/^enum ThreadStatus { JUST_CREATED, RUNNING, READY, BLOCKED };$/;"	g
ThreadTest	threads/main.cc	/^extern void ThreadTest(void), Copy(char *unixFile, char *nachosFile);$/;"	p	file:	signature:(void)
ThreadTest	threads/threadtest.cc	/^ThreadTest()$/;"	f	signature:()
TimeOfNextInterrupt	machine/timer.cc	/^Timer::TimeOfNextInterrupt() $/;"	f	class:Timer	signature:()
TimeOfNextInterrupt	machine/timer.h	/^    int TimeOfNextInterrupt();  \/\/ figure out when the timer will generate$/;"	p	class:Timer	access:public	signature:()
TimeToSeek	machine/disk.cc	/^Disk::TimeToSeek(int newSector, int *rotation) $/;"	f	class:Disk	signature:(int newSector, int *rotation)
TimeToSeek	machine/disk.h	/^    int TimeToSeek(int newSector, int *rotate); \/\/ time to get to the new track$/;"	p	class:Disk	access:private	signature:(int newSector, int *rotate)
Timer	machine/timer.cc	/^Timer::Timer(VoidFunctionPtr timerHandler, int callArg, bool doRandom)$/;"	f	class:Timer	signature:(VoidFunctionPtr timerHandler, int callArg, bool doRandom)
Timer	machine/timer.h	/^    Timer(VoidFunctionPtr timerHandler, int callArg, bool doRandom);$/;"	p	class:Timer	access:public	signature:(VoidFunctionPtr timerHandler, int callArg, bool doRandom)
Timer	machine/timer.h	/^class Timer {$/;"	c
Timer::TimeOfNextInterrupt	machine/timer.cc	/^Timer::TimeOfNextInterrupt() $/;"	f	class:Timer	signature:()
Timer::TimeOfNextInterrupt	machine/timer.h	/^    int TimeOfNextInterrupt();  \/\/ figure out when the timer will generate$/;"	p	class:Timer	access:public	signature:()
Timer::Timer	machine/timer.cc	/^Timer::Timer(VoidFunctionPtr timerHandler, int callArg, bool doRandom)$/;"	f	class:Timer	signature:(VoidFunctionPtr timerHandler, int callArg, bool doRandom)
Timer::Timer	machine/timer.h	/^    Timer(VoidFunctionPtr timerHandler, int callArg, bool doRandom);$/;"	p	class:Timer	access:public	signature:(VoidFunctionPtr timerHandler, int callArg, bool doRandom)
Timer::TimerExpired	machine/timer.cc	/^Timer::TimerExpired() $/;"	f	class:Timer	signature:()
Timer::TimerExpired	machine/timer.h	/^    void TimerExpired();	\/\/ called internally when the hardware$/;"	p	class:Timer	access:public	signature:()
Timer::arg	machine/timer.h	/^    int arg;			\/\/ argument to pass to interrupt handler$/;"	m	class:Timer	access:private
Timer::handler	machine/timer.h	/^    VoidFunctionPtr handler;	\/\/ timer interrupt handler $/;"	m	class:Timer	access:private
Timer::randomize	machine/timer.h	/^    bool randomize;		\/\/ set if we need to use a random timeout delay$/;"	m	class:Timer	access:private
Timer::~Timer	machine/timer.h	/^    ~Timer() {}$/;"	f	class:Timer	access:public	signature:()
TimerExpired	machine/timer.cc	/^Timer::TimerExpired() $/;"	f	class:Timer	signature:()
TimerExpired	machine/timer.h	/^    void TimerExpired();	\/\/ called internally when the hardware$/;"	p	class:Timer	access:public	signature:()
TimerHandler	machine/timer.cc	/^static void TimerHandler(int arg)$/;"	f	file:	signature:(int arg)
TimerInt	machine/interrupt.h	/^enum IntType { TimerInt, DiskInt, ConsoleWriteInt, ConsoleReadInt, $/;"	e	enum:IntType
TimerInterruptHandler	threads/system.cc	/^TimerInterruptHandler(int dummy)$/;"	f	file:	signature:(int dummy)
TimerTicks	machine/stats.h	58;"	d
TransferSize	filesys/fstest.cc	24;"	d	file:
Translate	machine/machine.h	/^    ExceptionType Translate(int virtAddr, int* physAddr, int size,bool writing);$/;"	p	class:Machine	access:public	signature:(int virtAddr, int* physAddr, int size,bool writing)
Translate	machine/translate.cc	/^Machine::Translate(int virtAddr, int* physAddr, int size, bool writing)$/;"	f	class:Machine	signature:(int virtAddr, int* physAddr, int size, bool writing)
TranslationEntry	machine/translate.h	/^class TranslationEntry {$/;"	c
TranslationEntry::dirty	machine/translate.h	/^    bool dirty;         \/\/ This bit is set by the hardware every time the$/;"	m	class:TranslationEntry	access:public
TranslationEntry::physicalPage	machine/translate.h	/^    int physicalPage;  	\/\/ The page number in real memory (relative to the$/;"	m	class:TranslationEntry	access:public
TranslationEntry::readOnly	machine/translate.h	/^    bool readOnly;	\/\/ If this bit is set, the user program is not allowed$/;"	m	class:TranslationEntry	access:public
TranslationEntry::use	machine/translate.h	/^    bool use;           \/\/ This bit is set by the hardware every time the$/;"	m	class:TranslationEntry	access:public
TranslationEntry::valid	machine/translate.h	/^    bool valid;         \/\/ If this bit is set, the translation is ignored.$/;"	m	class:TranslationEntry	access:public
TranslationEntry::virtualPage	machine/translate.h	/^    int virtualPage;  	\/\/ The page number in virtual memory.$/;"	m	class:TranslationEntry	access:public
Traptrace	bin/disasm.c	/^int TRACE, Traptrace, Regtrace;$/;"	v
Traptrace	bin/main.c	/^int TRACE, Traptrace, Regtrace;$/;"	v
TypeToReg	machine/mipssim.cc	/^TypeToReg(RegType reg, Instruction *instr)$/;"	f	file:	signature:(RegType reg, Instruction *instr)
UTILITY_H	threads/utility.h	24;"	d
Unlink	machine/sysdep.cc	/^Unlink(char *name)$/;"	f	signature:(char *name)
Unlink	machine/sysdep.h	/^extern bool Unlink(char *name);$/;"	p	signature:(char *name)
UpdateLast	machine/disk.cc	/^Disk::UpdateLast(int newSector)$/;"	f	class:Disk	signature:(int newSector)
UpdateLast	machine/disk.h	/^    void UpdateLast(int newSector);$/;"	p	class:Disk	access:private	signature:(int newSector)
UserMode	machine/interrupt.h	/^enum MachineStatus {IdleMode, SystemMode, UserMode};$/;"	e	enum:MachineStatus
UserStackSize	userprog/addrspace.h	19;"	d
UserTick	machine/stats.h	52;"	d
V	threads/synch.cc	/^Semaphore::V()$/;"	f	class:Semaphore	signature:()
V	threads/synch.h	/^    void V();	 \/\/ they are both *atomic*$/;"	p	class:Semaphore	access:public	signature:()
VoidFunctionPtr	threads/utility.h	/^typedef void (*VoidFunctionPtr)(int arg); $/;"	t
VoidNoArgFunctionPtr	threads/utility.h	/^typedef void (*VoidNoArgFunctionPtr)(); $/;"	t
Wait	threads/synch.cc	/^void Condition::Wait(Lock* conditionLock) { ASSERT(FALSE); }$/;"	f	class:Condition	signature:(Lock* conditionLock)
Wait	threads/synch.h	/^    void Wait(Lock *conditionLock); 	\/\/ these are the 3 operations on $/;"	p	class:Condition	access:public	signature:(Lock *conditionLock)
WhenDonePC	threads/switch.h	118;"	d
WhenDonePC	threads/switch.h	151;"	d
WhenDonePC	threads/switch.h	52;"	d
WhenDonePC	threads/switch.h	83;"	d
WhenDonePCState	threads/switch.h	124;"	d
WhenDonePCState	threads/switch.h	146;"	d
WhenDonePCState	threads/switch.h	59;"	d
WhenDonePCState	threads/switch.h	89;"	d
WordToHost	bin/coff2noff.c	/^WordToHost(unsigned int word) {$/;"	f	signature:(unsigned int word)
WordToHost	machine/machine.h	/^unsigned int WordToHost(unsigned int word);$/;"	p	signature:(unsigned int word)
WordToHost	machine/translate.cc	/^WordToHost(unsigned int word) {$/;"	f	signature:(unsigned int word)
WordToMachine	machine/machine.h	/^unsigned int WordToMachine(unsigned int word);$/;"	p	signature:(unsigned int word)
WordToMachine	machine/translate.cc	/^WordToMachine(unsigned int word) { return WordToHost(word); }$/;"	f	signature:(unsigned int word)
Write	bin/coff2flat.c	/^void Write(int fd, char *buf, int nBytes)$/;"	f	signature:(int fd, char *buf, int nBytes)
Write	bin/coff2noff.c	/^void Write(int fd, char *buf, int nBytes)$/;"	f	signature:(int fd, char *buf, int nBytes)
Write	filesys/openfile.cc	/^OpenFile::Write(char *into, int numBytes)$/;"	f	class:OpenFile	signature:(char *into, int numBytes)
Write	filesys/openfile.h	/^    int Write(char *from, int numBytes) {$/;"	f	class:OpenFile	access:public	signature:(char *from, int numBytes)
Write	filesys/openfile.h	/^    int Write(char *from, int numBytes);$/;"	p	class:OpenFile	access:public	signature:(char *from, int numBytes)
WriteAt	filesys/openfile.cc	/^OpenFile::WriteAt(char *from, int numBytes, int position)$/;"	f	class:OpenFile	signature:(char *from, int numBytes, int position)
WriteAt	filesys/openfile.h	/^    int WriteAt(char *from, int numBytes, int position) { $/;"	f	class:OpenFile	access:public	signature:(char *from, int numBytes, int position)
WriteAt	filesys/openfile.h	/^    int WriteAt(char *from, int numBytes, int position);$/;"	p	class:OpenFile	access:public	signature:(char *from, int numBytes, int position)
WriteBack	filesys/directory.cc	/^Directory::WriteBack(OpenFile *file)$/;"	f	class:Directory	signature:(OpenFile *file)
WriteBack	filesys/directory.h	/^    void WriteBack(OpenFile *file);	\/\/ Write modifications to $/;"	p	class:Directory	access:public	signature:(OpenFile *file)
WriteBack	filesys/filehdr.cc	/^FileHeader::WriteBack(int sector)$/;"	f	class:FileHeader	signature:(int sector)
WriteBack	filesys/filehdr.h	/^    void WriteBack(int sectorNumber); 	\/\/ Write modifications to file header$/;"	p	class:FileHeader	access:public	signature:(int sectorNumber)
WriteBack	userprog/bitmap.cc	/^BitMap::WriteBack(OpenFile *file)$/;"	f	class:BitMap	signature:(OpenFile *file)
WriteBack	userprog/bitmap.h	/^    void WriteBack(OpenFile *file); 	\/\/ write contents to disk$/;"	p	class:BitMap	access:public	signature:(OpenFile *file)
WriteDone	machine/console.cc	/^Console::WriteDone()$/;"	f	class:Console	signature:()
WriteDone	machine/console.h	/^    void WriteDone();	 	\/\/ internal routines to signal I\/O completion$/;"	p	class:Console	access:public	signature:()
WriteDone	network/post.cc	/^static void WriteDone(int arg)$/;"	f	file:	signature:(int arg)
WriteDone	userprog/exception.cc	/^static void WriteDone(int arg) { writeDone->V(); }$/;"	f	file:	signature:(int arg)
WriteDone	userprog/progtest.cc	/^static void WriteDone(int arg) { writeDone->V(); }$/;"	f	file:	signature:(int arg)
WriteFile	machine/sysdep.cc	/^WriteFile(int fd, char *buffer, int nBytes)$/;"	f	signature:(int fd, char *buffer, int nBytes)
WriteFile	machine/sysdep.h	/^extern void WriteFile(int fd, char *buffer, int nBytes);$/;"	p	signature:(int fd, char *buffer, int nBytes)
WriteMem	machine/machine.h	/^    bool WriteMem(int addr, int size, int value);$/;"	p	class:Machine	access:public	signature:(int addr, int size, int value)
WriteMem	machine/translate.cc	/^Machine::WriteMem(int addr, int size, int value)$/;"	f	class:Machine	signature:(int addr, int size, int value)
WriteRegister	machine/machine.cc	/^void Machine::WriteRegister(int num, int value)$/;"	f	class:Machine	signature:(int num, int value)
WriteRegister	machine/machine.h	/^    void WriteRegister(int num, int value);$/;"	p	class:Machine	access:public	signature:(int num, int value)
WriteRequest	machine/disk.cc	/^Disk::WriteRequest(int sectorNumber, char* data)$/;"	f	class:Disk	signature:(int sectorNumber, char* data)
WriteRequest	machine/disk.h	/^    void WriteRequest(int sectorNumber, char* data);$/;"	p	class:Disk	access:public	signature:(int sectorNumber, char* data)
WriteSector	filesys/synchdisk.cc	/^SynchDisk::WriteSector(int sectorNumber, char* data)$/;"	f	class:SynchDisk	signature:(int sectorNumber, char* data)
WriteSector	filesys/synchdisk.h	/^    void WriteSector(int sectorNumber, char* data);$/;"	p	class:SynchDisk	access:public	signature:(int sectorNumber, char* data)
YieldCPU	threads/thread.cc	/^NachOSThread::YieldCPU ()$/;"	f	class:NachOSThread	signature:()
YieldCPU	threads/thread.h	/^    void YieldCPU();  				\/\/ Relinquish the CPU if any $/;"	p	class:NachOSThread	access:public	signature:()
YieldOnReturn	machine/interrupt.cc	/^Interrupt::YieldOnReturn()$/;"	f	class:Interrupt	signature:()
YieldOnReturn	machine/interrupt.h	/^    void YieldOnReturn();		\/\/ cause a context switch on return $/;"	p	class:Interrupt	access:public	signature:()
_EAX	threads/switch.h	132;"	d
_EBP	threads/switch.h	136;"	d
_EBX	threads/switch.h	133;"	d
_ECX	threads/switch.h	134;"	d
_EDI	threads/switch.h	138;"	d
_EDX	threads/switch.h	135;"	d
_ESI	threads/switch.h	137;"	d
_ESP	threads/switch.h	131;"	d
_PC	threads/switch.h	139;"	d
_SWITCH	threads/thread.h	/^void _SWITCH(NachOSThread *oldThread, NachOSThread *newThread);$/;"	p	signature:(NachOSThread *oldThread, NachOSThread *newThread)
_ThreadRoot	threads/thread.h	/^void _ThreadRoot();$/;"	p	signature:()
_eax_save	threads/switch.s	/^        movl    _eax_save,%ebx          # get the saved value of eax$/;"	v
a0	threads/switch.s	/^	move	a0, InitialArg$/;"	v
a0	threads/switch.s	46;"	d	file:
a1	threads/switch.s	47;"	d	file:
abort	machine/sysdep.cc	/^void abort();$/;"	p	file:	signature:()
abs	machine/sysdep.h	/^int abs(int i);$/;"	p	signature:(int i)
active	machine/disk.h	/^    bool active;     			\/\/ Is a disk operation in progress?$/;"	m	class:Disk	access:private
addtable	bin/execute.c	/^int addtable[33][33];$/;"	v
amark	bin/int.h	15;"	d
aouthdr	bin/coff.h	/^typedef struct aouthdr {$/;"	s
aouthdr	bin/out.c	/^struct aouthdr aouthdr;$/;"	v	typeref:struct:aouthdr
aouthdr::bsize	bin/coff.h	/^        long    bsize;          \/* uninitialized data "   "             *\/$/;"	m	struct:aouthdr	access:public
aouthdr::bss_start	bin/coff.h	/^        long    bss_start;      \/* base of bss used for this file       *\/$/;"	m	struct:aouthdr	access:public
aouthdr::cprmask	bin/coff.h	/^        long    cprmask[4];     \/* co-processor register masks          *\/$/;"	m	struct:aouthdr	access:public
aouthdr::data_start	bin/coff.h	/^        long    data_start;     \/* base of data used for this file      *\/$/;"	m	struct:aouthdr	access:public
aouthdr::dsize	bin/coff.h	/^        long    dsize;          \/* initialized data "  "                *\/$/;"	m	struct:aouthdr	access:public
aouthdr::entry	bin/coff.h	/^        long    entry;          \/* entry pt.                            *\/$/;"	m	struct:aouthdr	access:public
aouthdr::gp_value	bin/coff.h	/^        long    gp_value;       \/* the gp value used for this object    *\/$/;"	m	struct:aouthdr	access:public
aouthdr::gprmask	bin/coff.h	/^        long    gprmask;        \/* general purpose register mask        *\/$/;"	m	struct:aouthdr	access:public
aouthdr::magic	bin/coff.h	/^        short   magic;          \/* see above                            *\/$/;"	m	struct:aouthdr	access:public
aouthdr::text_start	bin/coff.h	/^        long    text_start;     \/* base of text used for this file      *\/$/;"	m	struct:aouthdr	access:public
aouthdr::tsize	bin/coff.h	/^        long    tsize;          \/* text size in bytes, padded to DW bdry*\/$/;"	m	struct:aouthdr	access:public
aouthdr::vstamp	bin/coff.h	/^        short   vstamp;         \/* version stamp                        *\/$/;"	m	struct:aouthdr	access:public
arch1cycles	bin/execute.c	/^int arch1cycles;$/;"	v
arg	machine/interrupt.h	/^    int arg;                    \/\/ The argument to the function.$/;"	m	class:PendingInterrupt	access:public
arg	machine/timer.h	/^    int arg;			\/\/ argument to pass to interrupt handler$/;"	m	class:Timer	access:private
argc	bin/disasm.c	/^int argc;$/;"	v
argc	bin/disasm.c	/^int startpc, argc;$/;"	v
argc	bin/execute.c	/^int startpc, argc;$/;"	v
argc	bin/main.c	/^int argc;$/;"	v
argc	bin/out.c	/^int argc;$/;"	v
args	machine/mipssim.h	/^    RegType args[3];$/;"	m	struct:OpString	access:public
argv	bin/disasm.c	/^char *argv[];$/;"	v
argv	bin/execute.c	/^char *argv[];$/;"	v
argv	bin/main.c	/^char *argv[];$/;"	v
argv	bin/out.c	/^char *argv[];$/;"	v
atof	machine/sysdep.h	/^double atof(const char *str);$/;"	p	signature:(const char *str)
atoi	machine/sysdep.h	/^int atoi(const char *str);$/;"	p	signature:(const char *str)
b31	bin/execute.c	31;"	d	file:
bin	Makefile	/^	cd bin; make all$/;"	v
boxes	network/post.h	/^    MailBox *boxes;		\/\/ Table of mail boxes to hold incoming mail$/;"	m	class:PostOffice	access:private
bsize	bin/coff.h	/^        long    bsize;          \/* uninitialized data "   "             *\/$/;"	m	struct:aouthdr	access:public
bss_start	bin/coff.h	/^        long    bss_start;      \/* base of bss used for this file       *\/$/;"	m	struct:aouthdr	access:public
bsshead	bin/disasm.c	/^static SCNHDR texthead, rdatahead, datahead, sdatahead, sbsshead, bsshead;$/;"	v	file:
bsshead	bin/main.c	/^static SCNHDR texthead, rdatahead, datahead, sdatahead, sbsshead, bsshead;$/;"	v	file:
bufferInit	machine/disk.h	/^    int bufferInit;			\/\/ When the track buffer started $/;"	m	class:Disk	access:private
cc_add	bin/execute.c	34;"	d	file:
cc_logic	bin/execute.c	48;"	d	file:
cc_mulscc	bin/execute.c	54;"	d	file:
cc_sub	bin/execute.c	40;"	d	file:
cfetch	bin/int.h	22;"	d
chanceToWork	machine/network.h	/^    double chanceToWork;	\/\/ Likelihood packet will be dropped$/;"	m	class:Network	access:private
close	machine/sysdep.cc	/^int close(int filedes);$/;"	p	file:	signature:(int filedes)
code	bin/noff.h	/^   Segment code;		\/* executable code segment *\/ $/;"	m	struct:noffHeader	access:public
column	bin/out.c	/^static column = 1;$/;"	v	file:
console	userprog/progtest.cc	/^static Console *console;$/;"	v	file:
copyright	threads/copyright.h	/^static char *copyright = "Copyright (c) 1992-1993 The Regents of the University of California.  All rights reserved.";$/;"	v
counter	threads/switch.s	/^	stw  %rp, PC(%arg0)	;save program counter$/;"	v
cprmask	bin/coff.h	/^        long    cprmask[4];     \/* co-processor register masks          *\/$/;"	m	struct:aouthdr	access:public
created	README.md	/^GetPID - In order to assign pid, we create a static variable prpid which is a member of the NachOSThread class, initialize it to -1 in Initialize(). When a new thread is created, the prpid is incremented and assigned to pid. We have defined a getPID function in NachOSThread class. In exception.cc, we get the pid number using this function, place it in register 2 to return and then change program counters.$/;"	v
cstore	bin/int.h	29;"	d
currentOffset	filesys/openfile.h	/^    int currentOffset;$/;"	m	class:OpenFile	access:private
currentThread	threads/system.cc	/^NachOSThread *currentThread;			\/\/ the thread we are running now$/;"	v
d	userprog/machine.o	/^/;"	v
data	bin/out.c	/^  long data[MAXDATA];$/;"	m	struct:data	file:	access:public
data	bin/out.c	/^struct data {$/;"	s	file:
data	network/post.h	/^     char data[MaxMailSize];	\/\/ Payload -- message data$/;"	m	class:Mail	access:public
data::data	bin/out.c	/^  long data[MAXDATA];$/;"	m	struct:data	file:	access:public
data::length	bin/out.c	/^  int length;$/;"	m	struct:data	file:	access:public
data::reloc	bin/out.c	/^  struct reloc reloc[MAXRELOCS];$/;"	m	struct:data	typeref:struct:data::reloc	file:	access:public
data::relocs	bin/out.c	/^  int relocs;$/;"	m	struct:data	file:	access:public
dataSectors	filesys/filehdr.h	/^    int dataSectors[NumDirect];		\/\/ Disk sector numbers for each data $/;"	m	class:FileHeader	access:private
data_start	bin/coff.h	/^        long    data_start;     \/* base of data used for this file      *\/$/;"	m	struct:aouthdr	access:public
datahead	bin/disasm.c	/^static SCNHDR texthead, rdatahead, datahead, sdatahead, sbsshead, bsshead;$/;"	v	file:
datahead	bin/main.c	/^static SCNHDR texthead, rdatahead, datahead, sdatahead, sbsshead, bsshead;$/;"	v	file:
directoryFile	filesys/filesys.h	/^   OpenFile* directoryFile;		\/\/ "Root" directory -- list of $/;"	m	class:FileSystem	access:private
dirty	machine/translate.h	/^    bool dirty;         \/\/ This bit is set by the hardware every time the$/;"	m	class:TranslationEntry	access:public
disk	filesys/synchdisk.h	/^    Disk *disk;		  		\/\/ Raw disk device$/;"	m	class:SynchDisk	access:private
divRoundDown	threads/utility.h	47;"	d
divRoundUp	threads/utility.h	48;"	d
dsize	bin/coff.h	/^        long    dsize;          \/* initialized data "  "                *\/$/;"	m	struct:aouthdr	access:public
dump_reg	bin/execute.c	/^dump_reg()$/;"	f	signature:()
ebp	threads/switch.s	/^        movl    %ebp,%esp$/;"	v
ebp	threads/switch.s	/^        movl    %ebp,_EBP(%eax)$/;"	v
ebx	threads/switch.s	/^        movl    %ebx,_EAX(%eax)         # store it$/;"	v
ebx	threads/switch.s	/^        movl    %ebx,_EBX(%eax)         # save registers$/;"	v
ecx	threads/switch.s	/^        movl    %ecx,_ECX(%eax)$/;"	v
edi	threads/switch.s	/^        movl    %edi,_EDI(%eax)$/;"	v
edx	threads/switch.s	/^        movl    %edx,_EDX(%eax)$/;"	v
enableFlags	threads/utility.cc	/^static char *enableFlags = NULL; \/\/ controls which DEBUG messages are printed $/;"	v	file:
entry	bin/coff.h	/^        long    entry;          \/* entry pt.                            *\/$/;"	m	struct:aouthdr	access:public
esi	threads/switch.s	/^        movl    %esi,_ESI(%eax)$/;"	v
esp	threads/switch.s	/^        movl    %esp,_ESP(%eax)         # save stack pointer$/;"	v
exceptionNames	machine/machine.cc	/^static char* exceptionNames[] = { "no exception", "syscall", $/;"	v	file:
extend	bin/instr.h	21;"	d
extra	machine/machine.h	/^    int extra;       \/\/ Immediate or target or shamt field or offset.$/;"	m	class:Instruction	access:public
f	bin/out.c	/^FILE *f;$/;"	v
f_flags	bin/coff.h	/^        unsigned short  f_flags;        \/* flags *\/$/;"	m	struct:filehdr	access:public
f_magic	bin/coff.h	/^        unsigned short  f_magic;        \/* magic number *\/$/;"	m	struct:filehdr	access:public
f_nscns	bin/coff.h	/^        unsigned short  f_nscns;        \/* number of sections *\/$/;"	m	struct:filehdr	access:public
f_nsyms	bin/coff.h	/^        long            f_nsyms;        \/* sizeof(symbolic hdr) *\/$/;"	m	struct:filehdr	access:public
f_opthdr	bin/coff.h	/^        unsigned short  f_opthdr;       \/* sizeof(optional hdr) *\/$/;"	m	struct:filehdr	access:public
f_symptr	bin/coff.h	/^        long            f_symptr;       \/* file pointer to symbolic header *\/$/;"	m	struct:filehdr	access:public
f_timdat	bin/coff.h	/^        long            f_timdat;       \/* time & date stamp *\/$/;"	m	struct:filehdr	access:public
false	bin/execute.c	16;"	d	file:
fetch	bin/int.h	19;"	d
file	filesys/openfile.h	/^    int file;$/;"	m	class:OpenFile	access:private
fileSystem	threads/system.cc	/^FileSystem  *fileSystem;$/;"	v
filehdr	bin/coff.h	/^struct filehdr {$/;"	s
filehdr	bin/out.c	/^struct filehdr filehdr;$/;"	v	typeref:struct:filehdr
filehdr::f_flags	bin/coff.h	/^        unsigned short  f_flags;        \/* flags *\/$/;"	m	struct:filehdr	access:public
filehdr::f_magic	bin/coff.h	/^        unsigned short  f_magic;        \/* magic number *\/$/;"	m	struct:filehdr	access:public
filehdr::f_nscns	bin/coff.h	/^        unsigned short  f_nscns;        \/* number of sections *\/$/;"	m	struct:filehdr	access:public
filehdr::f_nsyms	bin/coff.h	/^        long            f_nsyms;        \/* sizeof(symbolic hdr) *\/$/;"	m	struct:filehdr	access:public
filehdr::f_opthdr	bin/coff.h	/^        unsigned short  f_opthdr;       \/* sizeof(optional hdr) *\/$/;"	m	struct:filehdr	access:public
filehdr::f_symptr	bin/coff.h	/^        long            f_symptr;       \/* file pointer to symbolic header *\/$/;"	m	struct:filehdr	access:public
filehdr::f_timdat	bin/coff.h	/^        long            f_timdat;       \/* time & date stamp *\/$/;"	m	struct:filehdr	access:public
filename	bin/disasm.c	/^char *filename;$/;"	v
filename	bin/disasm.c	/^static char filename[1000] = "a.out";	\/* default a.out file *\/$/;"	v	file:
filename	bin/main.c	/^char *filename;$/;"	v
filename	bin/main.c	/^static char filename[1000] = "a.out";	\/* default a.out file *\/$/;"	v	file:
fileno	machine/disk.h	/^    int fileno;				\/\/ UNIX file number for simulated disk $/;"	m	class:Disk	access:private
filesys	Makefile	/^	cd filesys; $(MAKE) depend$/;"	v
filesys	Makefile	/^	cd filesys; $(MAKE) nachos $/;"	v
first	threads/list.h	/^    ListElement *first;  	\/\/ Head of the list, NULL if list is empty$/;"	m	class:List	access:private
fmt	bin/execute.c	/^char fmt[] = "%6d";$/;"	v
fmt2	bin/execute.c	/^char fmt2[] = "------";$/;"	v
format	machine/mipssim.h	/^    int format;		\/* Format type (IFMT or JFMT or RFMT) *\/$/;"	m	struct:OpInfo	access:public
format	tags	/^!_TAG_FILE_FORMAT	2	\/extended format; --format=1 will not append ;" to lines\/$/;"	v
fp	bin/disasm.c	/^static FILE *fp;$/;"	v	file:
fp	bin/main.c	/^static FILE *fp;$/;"	v	file:
fp	threads/switch.s	/^	or	fp,z,z		# Clearing the frame pointer here$/;"	v
fp	threads/switch.s	/^	sw	fp, FP(a0)		# save frame pointer$/;"	v
fp	threads/switch.s	57;"	d	file:
freeMapFile	filesys/filesys.h	/^   OpenFile* freeMapFile;		\/\/ Bit map of free disk blocks,$/;"	m	class:FileSystem	access:private
from	machine/network.h	/^    NetworkAddress from;	\/\/ source machine ID$/;"	m	class:PacketHeader	access:public
from	network/README	/^Got "Got it!" from 0, box 1$/;"	v
from	network/README	/^Got "Got it!" from 1, box 1$/;"	v
from	network/post.h	/^    MailBoxAddress from;	\/\/ Mail box to reply to$/;"	m	class:MailHeader	access:public
getLevel	machine/interrupt.h	/^    IntStatus getLevel() {return level;}\/\/ Return whether interrupts$/;"	f	class:Interrupt	access:public	signature:()
getName	threads/synch.h	/^    char* getName() { return (name); }$/;"	f	class:Condition	access:public	signature:()
getName	threads/synch.h	/^    char* getName() { return name; }	\/\/ debugging assist$/;"	f	class:Lock	access:public	signature:()
getName	threads/synch.h	/^    char* getName() { return name;}			\/\/ debugging assist$/;"	f	class:Semaphore	access:public	signature:()
getName	threads/thread.h	/^    char* getName() { return (name); }$/;"	f	class:NachOSThread	access:public	signature:()
getNumInstr	threads/thread.h	/^    int getNumInstr() { return numInstr; }$/;"	f	class:NachOSThread	access:public	signature:()
getPID	threads/thread.h	/^    int getPID() { return pid; }$/;"	f	class:NachOSThread	access:public	signature:()
getPPID	threads/thread.h	/^    int getPPID() { return ppid; }$/;"	f	class:NachOSThread	access:public	signature:()
getStatus	machine/interrupt.h	/^    MachineStatus getStatus() { return status; } \/\/ idle, kernel, user$/;"	f	class:Interrupt	access:public	signature:()
gp_value	bin/coff.h	/^        long    gp_value;       \/* the gp value used for this object    *\/$/;"	m	struct:aouthdr	access:public
gprmask	bin/coff.h	/^        long    gprmask;        \/* general purpose register mask        *\/$/;"	m	struct:aouthdr	access:public
handler	machine/disk.h	/^    VoidFunctionPtr handler;		\/\/ Interrupt handler, to be invoked $/;"	m	class:Disk	access:private
handler	machine/interrupt.h	/^    VoidFunctionPtr handler;    \/\/ The function (in the hardware device$/;"	m	class:PendingInterrupt	access:public
handler	machine/timer.h	/^    VoidFunctionPtr handler;	\/\/ timer interrupt handler $/;"	m	class:Timer	access:private
handlerArg	machine/console.h	/^    int handlerArg;			\/\/ argument to be passed to the $/;"	m	class:Console	access:private
handlerArg	machine/disk.h	/^    int handlerArg;			\/\/ Argument to interrupt handler $/;"	m	class:Disk	access:private
handlerArg	machine/network.h	/^    int handlerArg;		\/\/ Argument to be passed to interrupt handler$/;"	m	class:Network	access:private
hd	bin/disasm.c	/^register SCNHDR *hd;$/;"	v
hdr	filesys/openfile.h	/^    FileHeader *hdr;			\/\/ Header for this file $/;"	m	class:OpenFile	access:private
hist	bin/execute.c	/^int n, hist;$/;"	v
hist	bin/execute.c	/^static int hist[NNNN];$/;"	v	file:
hists	bin/execute.c	/^static int hists[NH][NNN];$/;"	v	file:
hoflo	bin/execute.c	/^int hoflo[NH], htotal[NH];$/;"	v
hprint	bin/execute.c	/^hprint()$/;"	f	signature:()
htotal	bin/execute.c	/^int hoflo[NH], htotal[NH];$/;"	v
i	bin/execute.c	/^int i;$/;"	v
i	bin/out.c	/^int i,j;$/;"	v
i	bin/out.c	/^int i;$/;"	v
ident	machine/network.h	/^    NetworkAddress ident;	\/\/ This machine's network address$/;"	m	class:Network	access:private
idle	network/README	/^Ticks: total 57080, idle 56810, system 270, user 0$/;"	v
idle	network/README	/^Ticks: total 58530, idle 58260, system 270, user 0$/;"	v
idleTicks	machine/stats.h	/^    int idleTicks;       	\/\/ Time spent idle (no threads to run)$/;"	m	class:Statistics	access:public
ifetch	bin/int.h	18;"	d
imark	bin/int.h	16;"	d
immed	bin/instr.h	15;"	d
inFileAddr	bin/noff.h	/^  int inFileAddr;		\/* location of segment in this file *\/$/;"	m	struct:segment	access:public
inHandler	machine/interrupt.h	/^    bool inHandler;		\/\/ TRUE if we are running an interrupt handler$/;"	m	class:Interrupt	access:private
inHdr	machine/network.h	/^    PacketHeader inHdr;		\/\/ Information about arrived packet$/;"	m	class:Network	access:private
inUse	filesys/directory.h	/^    bool inUse;				\/\/ Is this directory entry in use?$/;"	m	class:DirectoryEntry	access:public
inbox	machine/network.h	/^    char inbox[MaxPacketSize];  \/\/ Data for arrived packet$/;"	m	class:Network	access:private
incNumInstr	threads/thread.h	/^    void incNumInstr() { numInstr++; }$/;"	f	class:NachOSThread	access:public	signature:()
incoming	machine/console.h	/^    char incoming;    			\/\/ Contains the character to be read,$/;"	m	class:Console	access:private
initData	bin/noff.h	/^   Segment initData;		\/* initialized data segment *\/$/;"	m	struct:noffHeader	access:public
initialized	network/README	/^Unfortunately, the way the network gets initialized, if things$/;"	v
initializedConsoleSemaphores	threads/system.cc	/^bool initializedConsoleSemaphores;$/;"	v
instruction	bin/d.c	/^int instruction, pc;$/;"	v
intLevelNames	machine/interrupt.cc	/^static char *intLevelNames[] = { "off", "on"};$/;"	v	file:
intTypeNames	machine/interrupt.cc	/^static char *intTypeNames[] = { "timer", "disk", "console write", $/;"	v	file:
interrupt	threads/system.cc	/^Interrupt *interrupt;			\/\/ interrupt status$/;"	v
isHeldByCurrentThread	threads/synch.h	/^    bool isHeldByCurrentThread();	\/\/ true if the current thread$/;"	p	class:Lock	access:public	signature:()
item	threads/list.h	/^     void *item; 	    	\/\/ pointer to item on the list$/;"	m	class:ListElement	access:public
j	bin/out.c	/^int i,j;$/;"	v
j	userprog/machine.o	/^/;"	v
key	threads/list.h	/^     int key;		    	\/\/ priority, for a sorted list$/;"	m	class:ListElement	access:public
last	threads/list.h	/^    ListElement *last;		\/\/ Last element of list$/;"	m	class:List	access:private
lastSector	machine/disk.h	/^    int lastSector;			\/\/ The previous disk request $/;"	m	class:Disk	access:private
ldptr	bin/disasm.c	/^static LDFILE *ldptr;$/;"	v	file:
ldptr	bin/main.c	/^static LDFILE *ldptr;$/;"	v	file:
length	bin/out.c	/^  int length;$/;"	m	struct:data	file:	access:public
length	machine/network.h	/^    unsigned length;	 	\/\/ bytes of packet data, excluding the $/;"	m	class:PacketHeader	access:public
length	network/post.h	/^    unsigned length;		\/\/ Bytes of message data (excluding the $/;"	m	class:MailHeader	access:public
level	machine/interrupt.h	/^    IntStatus level;		\/\/ are interrupts enabled or disabled?$/;"	m	class:Interrupt	access:private
list	threads/synchlist.h	/^    List *list;			\/\/ the unsynchronized list$/;"	m	class:SynchList	access:private
listEmpty	threads/synchlist.h	/^    Condition *listEmpty;	\/\/ wait in Remove if the list is empty$/;"	m	class:SynchList	access:private
lock	filesys/synchdisk.h	/^    Lock *lock;		  		\/\/ Only one read\/write request$/;"	m	class:SynchDisk	access:private
lock	threads/synchlist.h	/^    Lock *lock;			\/\/ enforce mutual exclusive access to the list$/;"	m	class:SynchList	access:private
longdis	bin/d.c	/^int longdis = 1;$/;"	v
machine	threads/system.cc	/^Machine *machine;	\/\/ user program memory and registers$/;"	v
machineState	threads/thread.h	/^    int machineState[MachineStateSize];  \/\/ all registers except for stackTop$/;"	m	class:NachOSThread	access:private
magic	bin/coff.h	/^        short   magic;          \/* see above                            *\/$/;"	m	struct:aouthdr	access:public
mailHdr	network/post.h	/^     MailHeader mailHdr;	\/\/ Header appended by PostOffice$/;"	m	class:Mail	access:public
main	bin/coff2flat.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	bin/coff2noff.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	test/forkjoin.c	/^main()$/;"	f	signature:()
main	test/halt.c	/^main()$/;"	f	signature:()
main	test/matmult.c	/^main()$/;"	f	signature:()
main	test/printtest.c	/^main()$/;"	f	signature:()
main	test/shell.c	/^main()$/;"	f	signature:()
main	test/sort.c	/^main()$/;"	f	signature:()
main	test/testexec.c	/^main()$/;"	f	signature:()
main	test/testregPA.c	/^main()$/;"	f	signature:()
main	test/testyield.c	/^main()$/;"	f	signature:()
main	test/vectorsum.c	/^main()$/;"	f	signature:()
main	threads/main.cc	/^main(int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
mainMemory	machine/machine.h	/^    char *mainMemory;		\/\/ physical memory to store user program,$/;"	m	class:Machine	access:public
malloc	bin/coff2flat.c	/^extern char *malloc();$/;"	p	file:	signature:()
map	userprog/bitmap.h	/^    unsigned int *map;			\/\/ bit storage$/;"	m	class:BitMap	access:private
max	threads/utility.h	44;"	d
mem	bin/disasm.c	/^char mem[MEMSIZE];		\/* main memory. use malloc later *\/$/;"	v
mem	bin/main.c	/^char mem[MEMSIZE];		\/* main memory. use malloc later *\/$/;"	v
memoffset	bin/int.h	12;"	d
messageAvailable	network/post.h	/^    Semaphore *messageAvailable;\/\/ V'ed when message has arrived from network$/;"	m	class:PostOffice	access:private
messageSent	network/post.h	/^    Semaphore *messageSent;	\/\/ V'ed when next message can be sent to network$/;"	m	class:PostOffice	access:private
messages	network/post.h	/^    SynchList *messages;	\/\/ A mailbox is just a list of arrived messages$/;"	m	class:MailBox	access:private
min	threads/utility.h	43;"	d
n	bin/disasm.c	/^int n;$/;"	v
n	bin/execute.c	/^int n, hist;$/;"	v
n	bin/execute.c	/^int n;$/;"	v
n	bin/main.c	/^int n;$/;"	v
n	bin/out.c	/^int n;$/;"	v
name	filesys/directory.h	/^    char name[FileNameMaxLen + 1];	\/\/ Text name for file, with +1 for $/;"	m	class:DirectoryEntry	access:public
name	threads/synch.h	/^    char* name;				\/\/ for debugging$/;"	m	class:Lock	access:private
name	threads/synch.h	/^    char* name;        \/\/ useful for debugging$/;"	m	class:Semaphore	access:private
name	threads/synch.h	/^    char* name;$/;"	m	class:Condition	access:private
name	threads/thread.h	/^    char* name;$/;"	m	class:NachOSThread	access:private
netAddr	network/post.h	/^    NetworkAddress netAddr;	\/\/ Network address of this machine$/;"	m	class:PostOffice	access:private
network	Makefile	/^	cd network; $(MAKE) depend$/;"	v
network	Makefile	/^	cd network; $(MAKE) nachos $/;"	v
network	network/post.h	/^    Network *network;		\/\/ Physical network connection$/;"	m	class:PostOffice	access:private
next	threads/list.h	/^     ListElement *next;		\/\/ next element on list, $/;"	m	class:ListElement	access:public
noffFileName	bin/coff2noff.c	/^char *noffFileName = NULL;$/;"	v
noffHeader	bin/noff.h	/^typedef struct noffHeader {$/;"	s
noffHeader::code	bin/noff.h	/^   Segment code;		\/* executable code segment *\/ $/;"	m	struct:noffHeader	access:public
noffHeader::initData	bin/noff.h	/^   Segment initData;		\/* initialized data segment *\/$/;"	m	struct:noffHeader	access:public
noffHeader::noffMagic	bin/noff.h	/^   int noffMagic;		\/* should be NOFFMAGIC *\/$/;"	m	struct:noffHeader	access:public
noffHeader::uninitData	bin/noff.h	/^   Segment uninitData;		\/* uninitialized data segment --$/;"	m	struct:noffHeader	access:public
noffMagic	bin/noff.h	/^   int noffMagic;		\/* should be NOFFMAGIC *\/$/;"	m	struct:noffHeader	access:public
normalops	bin/opstrings.c	/^char *normalops[] = {$/;"	v
numBits	userprog/bitmap.h	/^    int numBits;			\/\/ number of bits in the bitmap$/;"	m	class:BitMap	access:private
numBoxes	network/post.h	/^    int numBoxes;		\/\/ Number of mail boxes$/;"	m	class:PostOffice	access:private
numBytes	filesys/filehdr.h	/^    int numBytes;			\/\/ Number of bytes in the file$/;"	m	class:FileHeader	access:private
numConsoleCharsRead	machine/stats.h	/^    int numConsoleCharsRead;	\/\/ number of characters read from the keyboard$/;"	m	class:Statistics	access:public
numConsoleCharsWritten	machine/stats.h	/^    int numConsoleCharsWritten; \/\/ number of characters written to the display$/;"	m	class:Statistics	access:public
numDiskReads	machine/stats.h	/^    int numDiskReads;		\/\/ number of disk read requests$/;"	m	class:Statistics	access:public
numDiskWrites	machine/stats.h	/^    int numDiskWrites;		\/\/ number of disk write requests$/;"	m	class:Statistics	access:public
numInstr	threads/thread.h	/^    int numInstr;$/;"	m	class:NachOSThread	access:private
numPacketsRecvd	machine/stats.h	/^    int numPacketsRecvd;	\/\/ number of packets received over the network$/;"	m	class:Statistics	access:public
numPacketsSent	machine/stats.h	/^    int numPacketsSent;		\/\/ number of packets sent over the network$/;"	m	class:Statistics	access:public
numPageFaults	machine/stats.h	/^    int numPageFaults;		\/\/ number of virtual memory page faults$/;"	m	class:Statistics	access:public
numPagesInVM	userprog/addrspace.h	/^    unsigned int numPagesInVM;		\/\/ Number of pages in the virtual $/;"	m	class:ProcessAddrSpace	access:private
numSectors	filesys/filehdr.h	/^    int numSectors;			\/\/ Number of data sectors in the file$/;"	m	class:FileHeader	access:private
numWords	userprog/bitmap.h	/^    int numWords;			\/\/ number of words of bitmap storage$/;"	m	class:BitMap	access:private
numadds	bin/execute.c	/^int numadds=1, numsubs=1, numsuccesses, numcarries;$/;"	v
numcarries	bin/execute.c	/^int numadds=1, numsubs=1, numsuccesses, numcarries;$/;"	v
numjmpls	bin/execute.c	/^int numjmpls;$/;"	v
numsubs	bin/execute.c	/^int numadds=1, numsubs=1, numsuccesses, numcarries;$/;"	v
numsuccesses	bin/execute.c	/^int numadds=1, numsubs=1, numsuccesses, numcarries;$/;"	v
ny	bin/execute.c	/^ny()$/;"	f	signature:()
off16	bin/instr.h	19;"	d
off26	bin/instr.h	17;"	d
opCode	machine/machine.h	/^    char opCode;     \/\/ Type of instruction.  This is NOT the same as the$/;"	m	class:Instruction	access:public
opCode	machine/mipssim.h	/^    int opCode;		\/* Translated op code. *\/$/;"	m	struct:OpInfo	access:public
opStrings	machine/mipssim.h	/^static struct OpString opStrings[] = {$/;"	v	typeref:struct:OpString
opTable	machine/mipssim.h	/^static OpInfo opTable[] = {$/;"	v
open	machine/sysdep.cc	/^int open(const char *name, int flags, ...);$/;"	p	file:	signature:(const char *name, int flags, ...)
outfile	bin/out.c	/^static FILE *outfile = stdout;$/;"	v	file:
packetAvail	machine/network.h	/^    bool packetAvail;		\/\/ Packet has arrived, can be pulled off of$/;"	m	class:Network	access:private
pageTableSize	machine/machine.h	/^    unsigned int pageTableSize;$/;"	m	class:Machine	access:public
pc	bin/d.c	/^int instruction, pc;$/;"	v
pc	bin/disasm.c	/^int pc;$/;"	v
pending	machine/interrupt.h	/^    List *pending;		\/\/ the list of interrupts scheduled$/;"	m	class:Interrupt	access:private
physicalPage	machine/translate.h	/^    int physicalPage;  	\/\/ The page number in real memory (relative to the$/;"	m	class:TranslationEntry	access:public
pid	threads/thread.h	/^    int pid, ppid;			\/\/ My pid and my parent's pid$/;"	m	class:NachOSThread	access:private
pktHdr	network/post.h	/^     PacketHeader pktHdr;	\/\/ Header appended by Network$/;"	m	class:Mail	access:public
postOffice	threads/system.cc	/^PostOffice *postOffice;$/;"	v
ppid	threads/thread.h	/^    int pid, ppid;			\/\/ My pid and my parent's pid$/;"	m	class:NachOSThread	access:private
printf	bin/out.c	190;"	d	file:
printhist	bin/execute.c	/^printhist()$/;"	f	signature:()
printstatistics	bin/execute.c	/^printstatistics()$/;"	f	signature:()
prpid	threads/system.cc	/^int NachOSThread::prpid = -1;$/;"	m	class:NachOSThread	file:
prpid	threads/thread.h	/^    static int prpid;$/;"	m	class:NachOSThread	access:public
ptr	bin/system.c	/^int ptr;$/;"	v
putBusy	machine/console.h	/^    bool putBusy;    			\/\/ Is a PutChar operation in progress?$/;"	m	class:Console	access:private
queue	threads/synch.h	/^    List *queue;       \/\/ threads waiting in P() for the value to be > 0$/;"	m	class:Semaphore	access:private
r10	threads/switch.s	/^	stw  %r10, S7(%arg0)$/;"	v
r11	threads/switch.s	/^	stw  %r11, S8(%arg0)$/;"	v
r12	threads/switch.s	/^	stw  %r12, S9(%arg0)$/;"	v
r13	threads/switch.s	/^	stw  %r13, S10(%arg0)$/;"	v
r14	threads/switch.s	/^	stw  %r14, S11(%arg0)$/;"	v
r15	threads/switch.s	/^	stw  %r15, S12(%arg0)$/;"	v
r16	threads/switch.s	/^	stw  %r16, S13(%arg0)$/;"	v
r17	threads/switch.s	/^	stw  %r17, S14(%arg0)$/;"	v
r18	threads/switch.s	/^	stw  %r18, S15(%arg0)$/;"	v
r3	threads/switch.s	/^	stw  %r3, S0(%arg0)	;save callee-save registers$/;"	v
r31	threads/switch.s	/^	or   %r31, 0, %rp	;put return address in proper register$/;"	v
r5	threads/switch.s	/^	stw  %r5, S2(%arg0)$/;"	v
r6	threads/switch.s	/^	stw  %r6, S3(%arg0)$/;"	v
r7	threads/switch.s	/^	stw  %r7, S4(%arg0)$/;"	v
r8	threads/switch.s	/^	stw  %r8, S5(%arg0)$/;"	v
r9	threads/switch.s	/^	stw  %r9, S6(%arg0)$/;"	v
ra	threads/switch.s	/^	sw	ra, PC(a0)		# save return address$/;"	v
ra	threads/switch.s	58;"	d	file:
rand	machine/sysdep.cc	/^int rand(void);$/;"	p	file:	signature:(void)
randomize	machine/timer.h	/^    bool randomize;		\/\/ set if we need to use a random timeout delay$/;"	m	class:Timer	access:private
rd	bin/instr.h	11;"	d
rd	machine/machine.h	/^    char rs, rt, rd; \/\/ Three registers from instruction.$/;"	m	class:Instruction	access:public
rdatahead	bin/disasm.c	/^static SCNHDR texthead, rdatahead, datahead, sdatahead, sbsshead, bsshead;$/;"	v	file:
rdatahead	bin/main.c	/^static SCNHDR texthead, rdatahead, datahead, sdatahead, sbsshead, bsshead;$/;"	v	file:
readAvail	userprog/exception.cc	/^static Semaphore *readAvail;$/;"	v	file:
readAvail	userprog/progtest.cc	/^static Semaphore *readAvail;$/;"	v	file:
readFileNo	machine/console.h	/^    int readFileNo;			\/\/ UNIX file emulating the keyboard $/;"	m	class:Console	access:private
readHandler	machine/console.h	/^    VoidFunctionPtr readHandler; 	\/\/ Interrupt handler to call when $/;"	m	class:Console	access:private
readHandler	machine/network.h	/^    VoidFunctionPtr readHandler;  \/\/ Interrupt handler, signalling packet has $/;"	m	class:Network	access:private
readOnly	machine/translate.h	/^    bool readOnly;	\/\/ If this bit is set, the user program is not allowed$/;"	m	class:TranslationEntry	access:public
read_struct	bin/out.c	29;"	d	file:
reads	network/README	/^Console I\/O: reads 0, writes 0$/;"	v
reads	network/README	/^Disk I\/O: reads 2, writes 0$/;"	v
readyThreadList	threads/scheduler.h	/^    List *readyThreadList;  		\/\/ queue of threads that are ready to run,$/;"	m	class:NachOSscheduler	access:private
received	network/README	/^Network I\/O: packets received 2, sent 2$/;"	v
registers	machine/machine.h	/^    int registers[NumTotalRegs]; \/\/ CPU registers, for executing user programs$/;"	m	class:Machine	access:public
regstrings	bin/d.c	/^char *regstrings[] =$/;"	v
reloc	bin/out.c	/^  struct reloc reloc[MAXRELOCS];$/;"	m	struct:data	typeref:struct:data::reloc	file:	access:public
reloc_type	bin/out.c	/^char *reloc_type[] = {$/;"	v
relocs	bin/out.c	/^  int relocs;$/;"	m	struct:data	file:	access:public
rp	threads/switch.s	/^	or   %r31, 0, %rp	;put return address in proper register$/;"	v
rp	threads/switch.s	/^	stw  %rp, PC(%arg0)	;save program counter$/;"	v
rs	bin/instr.h	13;"	d
rs	machine/machine.h	/^    char rs, rt, rd; \/\/ Three registers from instruction.$/;"	m	class:Instruction	access:public
rt	bin/instr.h	12;"	d
rt	machine/machine.h	/^    char rs, rt, rd; \/\/ Three registers from instruction.$/;"	m	class:Instruction	access:public
runUntilTime	machine/machine.h	/^    int runUntilTime;		\/\/ drop back into the debugger when simulated$/;"	m	class:Machine	access:private
s	bin/main.c	/^char *s;$/;"	v
s	userprog/machine.o	/^/;"	v
s0	threads/switch.s	/^	sw	s0, S0(a0)		# save all the callee-save registers$/;"	v
s0	threads/switch.s	48;"	d	file:
s1	threads/switch.s	49;"	d	file:
s2	threads/switch.s	/^	sw	s2, S2(a0)$/;"	v
s2	threads/switch.s	50;"	d	file:
s3	threads/switch.s	/^	sw	s3, S3(a0)$/;"	v
s3	threads/switch.s	51;"	d	file:
s4	threads/switch.s	/^	sw	s4, S4(a0)$/;"	v
s4	threads/switch.s	52;"	d	file:
s5	threads/switch.s	/^	sw	s5, S5(a0)$/;"	v
s5	threads/switch.s	53;"	d	file:
s6	threads/switch.s	/^	sw	s6, S6(a0)$/;"	v
s6	threads/switch.s	54;"	d	file:
s7	threads/switch.s	/^	sw	s7, S7(a0)$/;"	v
s7	threads/switch.s	55;"	d	file:
s_flags	bin/coff.h	/^        long            s_flags;        \/* flags *\/$/;"	m	struct:scnhdr	access:public
s_lnnoptr	bin/coff.h	/^        long            s_lnnoptr;      \/* file ptr to gp histogram *\/$/;"	m	struct:scnhdr	access:public
s_name	bin/coff.h	/^        char            s_name[8];      \/* section name *\/$/;"	m	struct:scnhdr	access:public
s_nlnno	bin/coff.h	/^        unsigned short  s_nlnno;        \/* number of gp histogram entries *\/$/;"	m	struct:scnhdr	access:public
s_nreloc	bin/coff.h	/^        unsigned short  s_nreloc;       \/* number of relocation entries *\/$/;"	m	struct:scnhdr	access:public
s_paddr	bin/coff.h	/^        long            s_paddr;        \/* physical address, aliased s_nlib *\/$/;"	m	struct:scnhdr	access:public
s_relptr	bin/coff.h	/^        long            s_relptr;       \/* file ptr to relocation *\/$/;"	m	struct:scnhdr	access:public
s_scnptr	bin/coff.h	/^        long            s_scnptr;       \/* file ptr to raw data for section *\/$/;"	m	struct:scnhdr	access:public
s_size	bin/coff.h	/^        long            s_size;         \/* section size *\/$/;"	m	struct:scnhdr	access:public
s_vaddr	bin/coff.h	/^        long            s_vaddr;        \/* virtual address *\/$/;"	m	struct:scnhdr	access:public
sbsshead	bin/disasm.c	/^static SCNHDR texthead, rdatahead, datahead, sdatahead, sbsshead, bsshead;$/;"	v	file:
sbsshead	bin/main.c	/^static SCNHDR texthead, rdatahead, datahead, sdatahead, sbsshead, bsshead;$/;"	v	file:
scheduler	threads/system.cc	/^NachOSscheduler *scheduler;			\/\/ the ready list$/;"	v
scnhdr	bin/coff.h	/^struct scnhdr {$/;"	s
scnhdr	bin/out.c	/^struct scnhdr scnhdr[MAXSCNS];$/;"	v	typeref:struct:scnhdr
scnhdr::s_flags	bin/coff.h	/^        long            s_flags;        \/* flags *\/$/;"	m	struct:scnhdr	access:public
scnhdr::s_lnnoptr	bin/coff.h	/^        long            s_lnnoptr;      \/* file ptr to gp histogram *\/$/;"	m	struct:scnhdr	access:public
scnhdr::s_name	bin/coff.h	/^        char            s_name[8];      \/* section name *\/$/;"	m	struct:scnhdr	access:public
scnhdr::s_nlnno	bin/coff.h	/^        unsigned short  s_nlnno;        \/* number of gp histogram entries *\/$/;"	m	struct:scnhdr	access:public
scnhdr::s_nreloc	bin/coff.h	/^        unsigned short  s_nreloc;       \/* number of relocation entries *\/$/;"	m	struct:scnhdr	access:public
scnhdr::s_paddr	bin/coff.h	/^        long            s_paddr;        \/* physical address, aliased s_nlib *\/$/;"	m	struct:scnhdr	access:public
scnhdr::s_relptr	bin/coff.h	/^        long            s_relptr;       \/* file ptr to relocation *\/$/;"	m	struct:scnhdr	access:public
scnhdr::s_scnptr	bin/coff.h	/^        long            s_scnptr;       \/* file ptr to raw data for section *\/$/;"	m	struct:scnhdr	access:public
scnhdr::s_size	bin/coff.h	/^        long            s_size;         \/* section size *\/$/;"	m	struct:scnhdr	access:public
scnhdr::s_vaddr	bin/coff.h	/^        long            s_vaddr;        \/* virtual address *\/$/;"	m	struct:scnhdr	access:public
sdatahead	bin/disasm.c	/^static SCNHDR texthead, rdatahead, datahead, sdatahead, sbsshead, bsshead;$/;"	v	file:
sdatahead	bin/main.c	/^static SCNHDR texthead, rdatahead, datahead, sdatahead, sbsshead, bsshead;$/;"	v	file:
section	bin/out.c	/^struct data section[MAXSCNS];$/;"	v	typeref:struct:data
section_name	bin/out.c	/^char *section_name[] = {$/;"	v
sector	filesys/directory.h	/^    int sector;				\/\/ Location on disk to find the $/;"	m	class:DirectoryEntry	access:public
seekPosition	filesys/openfile.h	/^    int seekPosition;			\/\/ Current position within the file$/;"	m	class:OpenFile	access:private
segment	bin/noff.h	/^typedef struct segment {$/;"	s
segment::inFileAddr	bin/noff.h	/^  int inFileAddr;		\/* location of segment in this file *\/$/;"	m	struct:segment	access:public
segment::size	bin/noff.h	/^  int size;			\/* size of segment *\/$/;"	m	struct:segment	access:public
segment::virtualAddr	bin/noff.h	/^  int virtualAddr;		\/* location of segment in virt addr space *\/$/;"	m	struct:segment	access:public
select	machine/sysdep.cc	/^int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,$/;"	p	file:	signature:(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)
select	machine/sysdep.cc	/^int select(int numBits, void *readFds, void *writeFds, void *exceptFds, $/;"	p	file:	signature:(int numBits, void *readFds, void *writeFds, void *exceptFds, struct timeval *timeout)
self	bin/disasm.c	/^static char self[256];			\/* name of invoking program *\/$/;"	v	file:
self	bin/main.c	/^static char self[256];			\/* name of invoking program *\/$/;"	v	file:
semaphore	filesys/synchdisk.h	/^    Semaphore *semaphore; 		\/\/ To synchronize requesting thread $/;"	m	class:SynchDisk	access:private
sendBusy	machine/network.h	/^    bool sendBusy;		\/\/ Packet is being sent.$/;"	m	class:Network	access:private
sendLock	network/post.h	/^    Lock *sendLock;		\/\/ Only one outgoing message at a time$/;"	m	class:PostOffice	access:private
setPID	threads/thread.h	/^    void setPID() { this->pid = prpid + 1; prpid = pid;}$/;"	f	class:NachOSThread	access:public	signature:()
setPPID	threads/thread.h	/^    void setPPID(int ppid) { this->ppid = ppid; }$/;"	f	class:NachOSThread	access:public	signature:(int ppid)
setStatus	machine/interrupt.h	/^    void setStatus(MachineStatus st) { status = st; }$/;"	f	class:Interrupt	access:public	signature:(MachineStatus st)
setStatus	threads/thread.h	/^    void setStatus(ThreadStatus st) { status = st; }$/;"	f	class:NachOSThread	access:public	signature:(ThreadStatus st)
sfetch	bin/int.h	20;"	d
shamt	bin/instr.h	14;"	d
singleStep	machine/machine.h	/^    bool singleStep;		\/\/ drop back into the debugger after each$/;"	m	class:Machine	access:private
size	bin/noff.h	/^  int size;			\/* size of segment *\/$/;"	m	struct:segment	access:public
sleep	machine/sysdep.cc	/^unsigned sleep(unsigned);$/;"	p	file:	signature:(unsigned)
sleepThreadList	threads/scheduler.h	/^    List *sleepThreadList;$/;"	m	class:NachOSscheduler	access:private
sock	machine/network.h	/^    int sock;			\/\/ UNIX socket number for incoming packets$/;"	m	class:Network	access:private
sockName	machine/network.h	/^    char sockName[32];		\/\/ File name corresponding to UNIX socket$/;"	m	class:Network	access:private
socket	machine/sysdep.cc	/^int socket(int, int, int);$/;"	p	file:	signature:(int, int, int)
sp	threads/switch.s	/^	sw	sp, SP(a0)		# save new stack pointer$/;"	v
sp	threads/switch.s	56;"	d	file:
space	threads/thread.h	/^    ProcessAddrSpace *space;			\/\/ User code this thread is running.$/;"	m	class:NachOSThread	access:public
specialTable	machine/mipssim.h	/^static int specialTable[] = {$/;"	v
specialops	bin/opstrings.c	/^char *specialops[] = {$/;"	v
sptr	bin/d.c	/^int sptr;$/;"	v
srand	machine/sysdep.cc	/^void srand(unsigned seed);$/;"	p	file:	signature:(unsigned seed)
sspace	bin/out.c	/^char sspace[20000];$/;"	v
sstore	bin/int.h	27;"	d
stack	threads/thread.h	/^    int* stack; 	 		\/\/ Bottom of the stack $/;"	m	class:NachOSThread	access:private
stackTop	threads/thread.h	/^    int* stackTop;			 \/\/ the current stack pointer$/;"	m	class:NachOSThread	access:private
startpc	bin/disasm.c	/^int startpc, argc;$/;"	v
startpc	bin/execute.c	/^int startpc, argc;$/;"	v
stats	threads/system.cc	/^Statistics *stats;			\/\/ performance metrics$/;"	v
status	machine/interrupt.h	/^    MachineStatus status;	\/\/ idle, kernel mode, user mode$/;"	m	class:Interrupt	access:private
status	threads/thread.h	/^    ThreadStatus status;		\/\/ ready, running or blocked$/;"	m	class:NachOSThread	access:private
storage_class	bin/out.c	/^char *storage_class[] = {$/;"	v
store	bin/int.h	25;"	d
strcpy	bin/disasm.c	/^extern char *strcpy();$/;"	p	file:	signature:()
strcpy	bin/main.c	/^extern char *strcpy();$/;"	p	file:	signature:()
string	machine/mipssim.h	/^    char *string;	\/\/ Printed version of instruction$/;"	m	struct:OpString	access:public
subtable	bin/execute.c	/^int subtable[33][33];$/;"	v
symbol_type	bin/out.c	/^char *symbol_type[] = {$/;"	v
symbols	bin/out.c	/^EXTR symbols[MAXSYMS];$/;"	v
symhdr	bin/out.c	/^HDRR symhdr;$/;"	v
synchDisk	threads/system.cc	/^SynchDisk   *synchDisk;$/;"	v
system	network/README	/^Ticks: total 57080, idle 56810, system 270, user 0$/;"	v
system	network/README	/^Ticks: total 58530, idle 58260, system 270, user 0$/;"	v
systemTicks	machine/stats.h	/^    int systemTicks;	 	\/\/ Time spent executing system code$/;"	m	class:Statistics	access:public
system_break	bin/system.c	/^system_break()$/;"	f	signature:()
system_call_Close	userprog/syscall.h	/^void system_call_Close(OpenFileId id);$/;"	p	signature:(OpenFileId id)
system_call_Create	userprog/syscall.h	/^void system_call_Create(char *name);$/;"	p	signature:(char *name)
system_call_Exec	userprog/syscall.h	/^void system_call_Exec(char *name);$/;"	p	signature:(char *name)
system_call_Exit	userprog/syscall.h	/^void system_call_Exit(int status);	$/;"	p	signature:(int status)
system_call_Fork	userprog/syscall.h	/^int system_call_Fork(void);$/;"	p	signature:(void)
system_call_GetNumInstr	userprog/syscall.h	/^int system_call_GetNumInstr (void);$/;"	p	signature:(void)
system_call_GetPA	userprog/syscall.h	/^int system_call_GetPA (unsigned vaddr);$/;"	p	signature:(unsigned vaddr)
system_call_GetPID	userprog/syscall.h	/^int system_call_GetPID (void);$/;"	p	signature:(void)
system_call_GetPPID	userprog/syscall.h	/^int system_call_GetPPID (void);$/;"	p	signature:(void)
system_call_GetReg	userprog/syscall.h	/^int system_call_GetReg (int regno);$/;"	p	signature:(int regno)
system_call_GetTime	userprog/syscall.h	/^int system_call_GetTime (void);$/;"	p	signature:(void)
system_call_Halt	userprog/syscall.h	/^void system_call_Halt();		$/;"	p	signature:()
system_call_Join	userprog/syscall.h	/^int system_call_Join(SpaceId id); 	$/;"	p	signature:(SpaceId id)
system_call_Open	userprog/syscall.h	/^OpenFileId system_call_Open(char *name);$/;"	p	signature:(char *name)
system_call_PrintChar	userprog/syscall.h	/^void system_call_PrintChar (char x);$/;"	p	signature:(char x)
system_call_PrintInt	userprog/syscall.h	/^void system_call_PrintInt (int x);$/;"	p	signature:(int x)
system_call_PrintIntHex	userprog/syscall.h	/^void system_call_PrintIntHex (int x);$/;"	p	signature:(int x)
system_call_PrintString	userprog/syscall.h	/^void system_call_PrintString (char *x);$/;"	p	signature:(char *x)
system_call_Read	userprog/syscall.h	/^int system_call_Read(char *buffer, int size, OpenFileId id);$/;"	p	signature:(char *buffer, int size, OpenFileId id)
system_call_Sleep	userprog/syscall.h	/^void system_call_Sleep (unsigned);$/;"	p	signature:(unsigned)
system_call_Write	userprog/syscall.h	/^void system_call_Write(char *buffer, int size, OpenFileId id);$/;"	p	signature:(char *buffer, int size, OpenFileId id)
system_call_Yield	userprog/syscall.h	/^void system_call_Yield();		$/;"	p	signature:()
system_trap	bin/system.c	/^system_trap()$/;"	f	signature:()
tab	bin/execute.c	/^int tab[33][33];$/;"	v
table	filesys/directory.h	/^    DirectoryEntry *table;		\/\/ Table of pairs: $/;"	m	class:Directory	access:private
tableSize	filesys/directory.h	/^    int tableSize;			\/\/ Number of directory entries$/;"	m	class:Directory	access:private
tell	machine/sysdep.cc	/^int tell(int filedes);$/;"	p	file:	signature:(int filedes)
test	Makefile	/^	cd test; make all$/;"	v
text_start	bin/coff.h	/^        long    text_start;     \/* base of text used for this file      *\/$/;"	m	struct:aouthdr	access:public
texthead	bin/disasm.c	/^static SCNHDR texthead, rdatahead, datahead, sdatahead, sbsshead, bsshead;$/;"	v	file:
texthead	bin/main.c	/^static SCNHDR texthead, rdatahead, datahead, sdatahead, sbsshead, bsshead;$/;"	v	file:
threadToBeDestroyed	threads/system.cc	/^NachOSThread *threadToBeDestroyed;  		\/\/ the thread that just finished$/;"	v
threads	Makefile	/^	cd threads; $(MAKE) nachos$/;"	v
timer	threads/system.cc	/^Timer *timer;				\/\/ the hardware timer device,$/;"	v
tlb	machine/machine.h	/^    TranslationEntry *tlb;		\/\/ this pointer should be considered $/;"	m	class:Machine	access:public
to	machine/network.h	/^    NetworkAddress to;		\/\/ Destination machine ID$/;"	m	class:PacketHeader	access:public
to	network/post.h	/^    MailBoxAddress to;		\/\/ Destination mail box$/;"	m	class:MailHeader	access:public
top4	bin/instr.h	18;"	d
total	network/README	/^Ticks: total 57080, idle 56810, system 270, user 0$/;"	v
total	network/README	/^Ticks: total 58530, idle 58260, system 270, user 0$/;"	v
totalTicks	machine/stats.h	/^    int totalTicks;      	\/\/ Total time running Nachos$/;"	m	class:Statistics	access:public
true	bin/execute.c	15;"	d	file:
tsize	bin/coff.h	/^        long    tsize;          \/* text size in bytes, padded to DW bdry*\/$/;"	m	struct:aouthdr	access:public
type	machine/interrupt.h	/^    IntType type;		\/\/ for debugging$/;"	m	class:PendingInterrupt	access:public
u	bin/execute.c	/^u()				\/* unimplemented *\/$/;"	f	signature:()
u_to_int_addr	bin/system.c	/^char *u_to_int_addr();$/;"	p	file:	signature:()
u_to_int_fd	bin/system.c	/^u_to_int_fd(fd)$/;"	f	signature:(fd)
ucfetch	bin/int.h	23;"	d
uninitData	bin/noff.h	/^   Segment uninitData;		\/* uninitialized data segment --$/;"	m	struct:noffHeader	access:public
use	machine/translate.h	/^    bool use;           \/\/ This bit is set by the hardware every time the$/;"	m	class:TranslationEntry	access:public
userRegisters	threads/thread.h	/^    int userRegisters[NumTotalRegs];	\/\/ user-level CPU register state$/;"	m	class:NachOSThread	access:private
userTicks	machine/stats.h	/^    int userTicks;       	\/\/ Time spent executing user code$/;"	m	class:Statistics	access:public
userprog	Makefile	/^	cd userprog; $(MAKE) depend $/;"	v
userprog	Makefile	/^	cd userprog; $(MAKE) nachos $/;"	v
usfetch	bin/int.h	21;"	d
valid	machine/translate.h	/^    bool valid;         \/\/ If this bit is set, the translation is ignored.$/;"	m	class:TranslationEntry	access:public
value	machine/machine.h	/^    unsigned int value; \/\/ binary representation of the instruction$/;"	m	class:Instruction	access:public
value	threads/synch.h	/^    int value;         \/\/ semaphore value, always >= 0$/;"	m	class:Semaphore	access:private
virtualAddr	bin/noff.h	/^  int virtualAddr;		\/* location of segment in virt addr space *\/$/;"	m	struct:segment	access:public
virtualPage	machine/translate.h	/^    int virtualPage;  	\/\/ The page number in virtual memory.$/;"	m	class:TranslationEntry	access:public
vm	Makefile	/^	cd vm; $(MAKE) depend$/;"	v
vm	Makefile	/^	cd vm; $(MAKE) nachos $/;"	v
vstamp	bin/coff.h	/^        short   vstamp;         \/* version stamp                        *\/$/;"	m	struct:aouthdr	access:public
when	machine/interrupt.h	/^    int when;			\/\/ When the interrupt is supposed to fire$/;"	m	class:PendingInterrupt	access:public
writeDone	userprog/exception.cc	/^static Semaphore *writeDone;$/;"	v	file:
writeDone	userprog/progtest.cc	/^static Semaphore *writeDone;$/;"	v	file:
writeFileNo	machine/console.h	/^    int writeFileNo;			\/\/ UNIX file emulating the display$/;"	m	class:Console	access:private
writeHandler	machine/console.h	/^    VoidFunctionPtr writeHandler; 	\/\/ Interrupt handler to call when $/;"	m	class:Console	access:private
writeHandler	machine/network.h	/^    VoidFunctionPtr writeHandler; \/\/ Interrupt handler, signalling next packet $/;"	m	class:Network	access:private
xpc	bin/disasm.c	/^int xpc;$/;"	v
yieldOnReturn	machine/interrupt.h	/^    bool yieldOnReturn; 	\/\/ TRUE if we are to context switch$/;"	m	class:Interrupt	access:private
z	threads/switch.s	/^	or	fp,z,z		# Clearing the frame pointer here$/;"	v
z	threads/switch.s	45;"	d	file:
~BitMap	userprog/bitmap.cc	/^BitMap::~BitMap()$/;"	f	class:BitMap	signature:()
~BitMap	userprog/bitmap.h	/^    ~BitMap();			\/\/ De-allocate bitmap$/;"	p	class:BitMap	access:public	signature:()
~Condition	threads/synch.cc	/^Condition::~Condition() { }$/;"	f	class:Condition	signature:()
~Condition	threads/synch.h	/^    ~Condition();			\/\/ deallocate the condition$/;"	p	class:Condition	access:public	signature:()
~Console	machine/console.cc	/^Console::~Console()$/;"	f	class:Console	signature:()
~Console	machine/console.h	/^    ~Console();			\/\/ clean up console emulation$/;"	p	class:Console	access:public	signature:()
~Directory	filesys/directory.cc	/^Directory::~Directory()$/;"	f	class:Directory	signature:()
~Directory	filesys/directory.h	/^    ~Directory();			\/\/ De-allocate the directory$/;"	p	class:Directory	access:public	signature:()
~Disk	machine/disk.cc	/^Disk::~Disk()$/;"	f	class:Disk	signature:()
~Disk	machine/disk.h	/^    ~Disk();				\/\/ Deallocate the disk.$/;"	p	class:Disk	access:public	signature:()
~Interrupt	machine/interrupt.cc	/^Interrupt::~Interrupt()$/;"	f	class:Interrupt	signature:()
~Interrupt	machine/interrupt.h	/^    ~Interrupt();			\/\/ de-allocate data structures$/;"	p	class:Interrupt	access:public	signature:()
~List	threads/list.cc	/^List::~List()$/;"	f	class:List	signature:()
~List	threads/list.h	/^    ~List();			\/\/ de-allocate the list$/;"	p	class:List	access:public	signature:()
~Lock	threads/synch.cc	/^Lock::~Lock() {}$/;"	f	class:Lock	signature:()
~Lock	threads/synch.h	/^    ~Lock();				\/\/ deallocate lock$/;"	p	class:Lock	access:public	signature:()
~Machine	machine/machine.cc	/^Machine::~Machine()$/;"	f	class:Machine	signature:()
~Machine	machine/machine.h	/^    ~Machine();			\/\/ De-allocate the data structures$/;"	p	class:Machine	access:public	signature:()
~MailBox	network/post.cc	/^MailBox::~MailBox()$/;"	f	class:MailBox	signature:()
~MailBox	network/post.h	/^    ~MailBox();			\/\/ De-allocate mail box$/;"	p	class:MailBox	access:public	signature:()
~NachOSThread	threads/thread.cc	/^NachOSThread::~NachOSThread()$/;"	f	class:NachOSThread	signature:()
~NachOSThread	threads/thread.h	/^    ~NachOSThread(); 				\/\/ deallocate a Thread$/;"	p	class:NachOSThread	access:public	signature:()
~NachOSscheduler	threads/scheduler.cc	/^NachOSscheduler::~NachOSscheduler()$/;"	f	class:NachOSscheduler	signature:()
~NachOSscheduler	threads/scheduler.h	/^    ~NachOSscheduler();			\/\/ De-allocate ready list$/;"	p	class:NachOSscheduler	access:public	signature:()
~Network	machine/network.cc	/^Network::~Network()$/;"	f	class:Network	signature:()
~Network	machine/network.h	/^    ~Network();			\/\/ De-allocate the network driver data$/;"	p	class:Network	access:public	signature:()
~OpenFile	filesys/openfile.cc	/^OpenFile::~OpenFile()$/;"	f	class:OpenFile	signature:()
~OpenFile	filesys/openfile.h	/^    ~OpenFile() { Close(file); }			\/\/ close the file$/;"	f	class:OpenFile	access:public	signature:()
~OpenFile	filesys/openfile.h	/^    ~OpenFile();			\/\/ Close the file$/;"	p	class:OpenFile	access:public	signature:()
~PostOffice	network/post.cc	/^PostOffice::~PostOffice()$/;"	f	class:PostOffice	signature:()
~PostOffice	network/post.h	/^    ~PostOffice();		\/\/ De-allocate Post Office data$/;"	p	class:PostOffice	access:public	signature:()
~ProcessAddrSpace	userprog/addrspace.cc	/^ProcessAddrSpace::~ProcessAddrSpace()$/;"	f	class:ProcessAddrSpace	signature:()
~ProcessAddrSpace	userprog/addrspace.h	/^    ~ProcessAddrSpace();			\/\/ De-allocate an address space$/;"	p	class:ProcessAddrSpace	access:public	signature:()
~Semaphore	threads/synch.cc	/^Semaphore::~Semaphore()$/;"	f	class:Semaphore	signature:()
~Semaphore	threads/synch.h	/^    ~Semaphore();   					\/\/ de-allocate semaphore$/;"	p	class:Semaphore	access:public	signature:()
~SynchDisk	filesys/synchdisk.cc	/^SynchDisk::~SynchDisk()$/;"	f	class:SynchDisk	signature:()
~SynchDisk	filesys/synchdisk.h	/^    ~SynchDisk();			\/\/ De-allocate the synch disk data$/;"	p	class:SynchDisk	access:public	signature:()
~SynchList	threads/synchlist.cc	/^SynchList::~SynchList()$/;"	f	class:SynchList	signature:()
~SynchList	threads/synchlist.h	/^    ~SynchList();		\/\/ de-allocate a synchronized list$/;"	p	class:SynchList	access:public	signature:()
~Timer	machine/timer.h	/^    ~Timer() {}$/;"	f	class:Timer	access:public	signature:()
